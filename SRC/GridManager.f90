! http://alienryderflex.com/polygon/
! www.codeproject.com/Tips/84226/Is-a-Point-inside-a-Polygon
! //  Globals which should be set before calling this function:
! //
! //  int    polyCorners  =  how many corners the polygon has (no repeats)
! //  float  polyX[]      =  horizontal coordinates of corners
! //  float  polyY[]      =  vertical coordinates of corners
! //  float  x, y         =  point to be tested
! //
! //  (Globals are used in this example for purposes of speed.  Change as
! //  desired.)
! //
! //  The function will return YES if the point x,y is inside the polygon, or
! //  NO if it is not.  If the point is exactly on the edge of the polygon,
! //  then the function may return YES or NO.
! //
! //  Note that division by zero is avoided because the division is protected
! //  by the "if" clause which surrounds it.

module Grid_Manager_Mod
use globals
implicit none

integer, parameter :: max_num_areas = 25
integer, parameter :: max_sides = 8

!> @class Grid_Data_Class
type Grid_Data_Class
    !> @public @memberof Grid_Data_Class
    !! UTM Easting
    real(dp) x
    !> @public @memberof Grid_Data_Class
    !! UTM Northing
    real(dp) y
    !> @public @memberof Grid_Data_Class
    !! Longitude
    real(dp) lon
    !> @public @memberof Grid_Data_Class
    !! Latitude
    real(dp) lat
    !> @public @memberof Grid_Data_Class
    !! bathymetric depth at (x,y)
    real(dp) z
    !> @public @memberof Grid_Data_Class
    !! Indicates if grid is closed for fishing
    logical is_closed
    !> @public @memberof Grid_Data_Class
    !! Indexed special area
    integer special_area_index
end type Grid_Data_Class

type LonLatPoint
real(dp) lon
real(dp) lat
end type LonLatPoint

type LonLatVector
real(dp) lon(max_sides)
real(dp) lat(max_sides)
integer n_sides
end type LonLatVector

type(LonLatVector), PRIVATE :: area(max_num_areas)
integer, PRIVATE :: num_areas
integer, PRIVATE :: num_grids
character(100), PRIVATE :: config_file_name
character(100), PRIVATE :: init_cond_file_name


CONTAINS

!==================================================================================================================
!> @public @memberof GridManager
!>
!> Initializes growth for startup
!>
!==================================================================================================================
subroutine Set_Grid_Manager(state, grid, ngrids)
    real(dp), intent(out):: state(1:num_dimensions, 1:num_size_classes)
    type(Grid_Data_Class), intent(inout) :: grid(*)
    integer, intent(out) :: ngrids

    integer n, j

    ! Load Grid. k
    ! read in grid and state from file_name
    ngrids = Load_Grid_State(grid, state)
    ! set private variable
    num_grids = ngrids

    call Load_Area_Coordinates()

    do n = 1, num_grids
        ! Check if any grids are in a special area
        j = Check_Grid_In_Special_Area(grid(n)%lon, grid(n)%lat)
        if (j > 0) then
            grid(n)%special_area_index = j
        endif
    enddo
endsubroutine Set_Grid_Manager

!-----------------------------------------------------------------------------------------------
!! @public @memberof GridManager
!> Used during instantiation to set the name of the file to read to for configuration parameters
!> @brief Read Input File
!> 
!> Sets name of a configuration file, used to set the coordinates for the special areas
!-----------------------------------------------------------------------------------------------
subroutine Set_Config_File_Name(fname)
    character(*), intent(in) :: fname
    config_file_name = config_dir//fname
    PRINT *, term_blu,config_file_name,term_blk
endsubroutine Set_Config_File_Name

!-----------------------------------------------------------------------------------------------
!! @public @memberof GridManager
!> Used during instantiation to set the name of the file to read to for grid locations, state
!> @brief Read Input File
!> 
!> Sets name of a configuration file, 'Data/bin5mmYYYY[MA|GB].csv'
!-----------------------------------------------------------------------------------------------
subroutine Set_Init_Cond_File_Name(fname)
    character(*), intent(in) :: fname
    init_cond_file_name = fname
    PRINT *, term_blu,init_cond_file_name,term_blk
endsubroutine Set_Init_Cond_File_Name

!==================================================================================================================
!> @fn Load_Grid_State
!> @public @memberof Grid_Manager_Mod
!>
!> This function is used to set the grid parameters and the initial state to start the simulation. 
!>
!> It does so by reading the CSV file at file_name. This file has been generated by the TrawlData5mm.m 
!> Matlab script. The format is for each grid in a row, the columns are
!> Decimal Year, UTM X, UTM Y, Latitude, Longitude, UTM Z, Grid Is Closed, Followed by Scallop Density in Count/m^2
!> sorted by shell length 30 to 150 mm in 5mm increments for 25 columns
!>
!> @param[in, out] grid Holds position information 
!> @param[out] state Holds the initial state at various location specified by grid
!> @param[in] file_name CSV name to be read in
!>
!==================================================================================================================
integer function Load_Grid_State(grid, state)
    type(Grid_Data_Class), intent(inout) :: grid(*)
    real(dp), intent(out):: state(1:num_dimensions, 1:num_size_classes)

    character(2000) input_str
    integer n, io, is_closed

    real(dp) year ! used as place holder when reading file_name

    PRINT *, 'OPENING ', init_cond_file_name

    open(63, file=init_cond_file_name, status='old')
    n = 0
    do
        read(63,'(a)',iostat=io) input_str
        if (io.lt.0) exit
        n=n+1
        read(input_str,*) year, grid(n)%x, grid(n)%y, grid(n)%lat, grid(n)%lon, grid(n)%z, &
        &               is_closed, state(n,1:num_size_classes)
        grid(n)%is_closed = (is_closed > 0)
        grid(n)%special_area_index = 0
    end do
    close(63)
    write(*,*) term_blu, 'READ ', n, 'LINE(S)', term_blk

    Load_Grid_State = n

endfunction Load_Grid_State

!==================================================================================================================
!> @public @memberof Grid_Manager_Mod
!==================================================================================================================
subroutine Load_Area_Coordinates()
    ! 10 edges time 12 characters, SXX.XXXXXX, plus padding
    character(150) input_str, sub_str
    integer n, io
    integer edge_lon, edge_lat, j

    PRINT *, 'OPENING ', config_file_name

    open(63, file=config_file_name, status='old')
    n = 0
    do
        read(63,'(a)',iostat=io) input_str
        if (io.lt.0) exit

        if (input_str(1:1) .ne. '#') then

            n=n+1
            ! read longitude value
            edge_lon = 0
            sub_str = input_str
            j = len(input_str)

            do while (j.ne.0)
                edge_lon = edge_lon + 1
                read(sub_str,*) area(n)%lon(edge_lon)
                j = index(sub_str,',')
                sub_str = sub_str(j+1:)
            enddo

            ! read latitude value
            read(63,'(a)',iostat=io) input_str
            if (io.lt.0) exit

            edge_lat = 0
            sub_str = input_str
            j = len(input_str)

            do while (j.ne.0)
                edge_lat = edge_lat + 1
                read(sub_str,*) area(n)%lat(edge_lat)
                j = index(sub_str,',')
                sub_str = sub_str(j+1:)
            enddo

            write(*,*) area(n)%lon(1:edge_lon)
            write(*,*) area(n)%lat(1:edge_lat)
            write(*,*)

            if (edge_lon .ne. edge_lat) then
                write(*,*) term_red, 'INVALID SPECIAL AREA FILE: at set ', n, term_blk
                stop
            endif
            area(n)%n_sides = edge_lat
        endif
    end do
    close(63)
    write(*,*) term_blu, 'READ ', n, 'AREAS', term_blk
    num_areas = n
endsubroutine

!==================================================================================================================
!> @public @memberof Grid_Manager_Mod
!==================================================================================================================
integer function Check_Grid_In_Special_Area(lon, lat)
    real(dp), intent(in) :: lon, lat

    integer a

    Check_Grid_In_Special_Area = -1
    do a = 1, num_areas
        if (Point_In_Polygon_Vector(area(a)%lon, area(a)%lat, lon, lat, area(a)%n_sides)) then
            Check_Grid_In_Special_Area = a
            exit
        endif
    enddo
endfunction Check_Grid_In_Special_Area

!==================================================================================================================
!> @fn Load_Grid_State
!> @public @memberof Grid_Manager_Mod
!> @param poly Array of x,y coordinates that define polygram,
!> @param point x,y coordinate of point we wish to determine if inside polygram
!> @param nodes the number of corners, edges, that define the polygon
!> @returns true if point is inside polygram, false if outsied
!>          if point is on an edge then is may return true of false
!==================================================================================================================
logical function Point_In_Polygon_Points(poly, point, nodes)

    type(LonLatPoint), intent(in) :: poly(*)
    type(LonLatPoint), intent(in) :: point
    integer, intent(in) :: nodes

    Point_In_Polygon_Points = Point_In_Polygon_Vector(poly(1:nodes)%lon, poly(1:nodes)%lat, point%lon, point%lat, nodes)

    return
endfunction Point_In_Polygon_Points

!==================================================================================================================
!> @fn Load_Grid_State
!> @public @memberof Grid_Manager_Mod
!> @param poly Array of x,y coordinates that define polygram,
!> @param point x,y coordinate of point we wish to determine if inside polygram
!> @param nodes the number of corners, edges, that define the polygon
!> @returns true if point is inside polygram, false if outsied
!>          if point is on an edge then is may return true of false
!==================================================================================================================
logical function Point_In_Polygon_Array(poly, point, nodes)

    real(dp), intent(in) :: poly(4,2)
    real(dp), intent(in) :: point(2)
    integer, intent(in) :: nodes

    Point_In_Polygon_Array = Point_In_Polygon_Vector(poly(1:nodes,1), poly(1:nodes,2), point(1), point(2), nodes)

    return
endfunction Point_In_Polygon_Array

!==================================================================================================================
!> @fn Load_Grid_State
!> @public @memberof Grid_Manager_Mod
!> First of all, notice that each iteration considers two adjacent points and the target point. 
!> Then the if statement evaluates two conditions:
!>
!> 1.) Y-value of our target point is within the range [verty[j], verty[i]).
!> 2.) X-value of our target point is below the linear line connecting the point j and i.
!> If you're having problems to see this second condition, just write down the linear equation of the line,
!> reorganize the expression a little bit and place testy as the free variable.
!>
!> Every time the above two conditions are met, we toggle the flag c. So we return true if 
!> above conditions are met odd number of times and false otherwise.
!>
!> @param polyX Array of horizontal, coordinates of corners
!> @param polyY Array of vertical    coordinates of corners
!> @param x horizontal coordinate of point we wish to determine if inside polygram
!> @param y vertical   coordinate of point we wish to determine if inside polygram
!> @param nodes the number of corners, edges, that define the polygon
!> @returns true if point is inside polygram or if on vert or horiz edge,
!           false if outside
!>          if point is on rise of falling edge then it may return true or false
!==================================================================================================================
logical function Point_In_Polygon_Vector(polyX, polyY, x, y, nodes)

    real(dp), intent(in) :: polyX(*)
    real(dp), intent(in) :: polyY(*)
    real(dp), intent(in) :: x
    real(dp), intent(in) :: y
    integer, intent(in) :: nodes

    integer   i, j
    logical inPolygon
    logical ind1, ind2, ind3

    inPolygon=.FALSE.
    j = nodes

    do i = 1, nodes
        ind1 = polyY(i) < y .AND. polyY(j) >= y
        ind2 = polyY(j) < y .AND. polyY(i) >= y
        ind3 = polyX(i) + (y - polyY(i)) / (polyY(j) - polyY(i)) * (polyX(j) - polyX(i)) < x
        if ((ind1 .or. ind2) .and. (ind3)) inPolygon = .NOT. inPolygon
        j = i
    enddo
    Point_In_Polygon_Vector = inPolygon

    return
endfunction Point_In_Polygon_Vector

endmodule Grid_Manager_Mod
