!--------------------------------------------------------------------------------------------------
!> @mainpage Universal Kriging
!>
!> Purpose: This program is designed to simulate random fields under the assumptions of Universal 
!> Kriging (UK).  It is assumed that the underlying spatial field is a linear combination of known 
!> spatial functions and a stationary zero mean random field with known variogram parameters.  The 
!> program can be configured in two ways:
!>
!> (1) To simulate random fields conditioned on the assumed UK model and a set of observations.
!>     (postrior simulation).
!>
!> (0) To simulate random fields based on specified mean spatial coefficients, their covariance
!>     and known variogram with known parameters (prior simulation).
!>
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!> 
!> @section m1p1 Implementation of random recruitment
!> Spatial fields of recruitment are generated by the software located in directory "/UKsrc".  The output files, such as:
!> "RecruitField/RecruityyyyMA/RandomFieldxx.txt" contain @f$n_{nodes}@f$ vectors of independent random fields conditioned on 
!> survey observations from "Data/RecruitsyyyyMA.csv", where xx runs from @f$1@f$ to @f$Nrand@f$ and @f$yyyy@f$ 1979 to 2018.
!>
!> @subsection m1p1p1 Interpolation Algorithm
!> The interpolation of recruit data is carried out with a Universal Kriging (UK) algorithm allowing for sampling from the posterior distribution. 
!>
!> @subsubsection m1p1p1p1 Universal Kriging
!> Universal kriging (UK) is a generalization of ordinary kriging in which a set of spatial functions are used to model the
!> trend of a set of point observations.  The underlying model is:
!> @f[
!> f(x,y,H(x,y),\lambda)=\sum_{k=1}^{n_f} f_k(x,y,H(x,y),\lambda_k) +\epsilon(x,y) 
!> @f] 
!> where @f$f_k@f$ are the known spatial functions and @f$\epsilon(x,y)@f$ is a zero mean, spatially correlated,  stationary random 
!> process with semi-variogram @f$\gamma(s)@f$. For a summary of UK see Cressie 1993, pages 151 -180.\n
!> % The spatially variable @f$x@f$ here is taken to include latitude, longitude and, bathymetric depth(@f$x=[lat,lon,z(lat,lon)]@f$). 
!> 
!> @subsubsection m1p1p1p2 Spatial functions
!> The spatial functions (SF) used here are  a set of one dimensional, bounded, C-infinity functions with two parameters, 
!> 
!> Gaussian Bump:
!> @f[
!> f_a (s,\lambda,x_0) = \exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Logistic curve:
!> @f[
!> f_b (s,\lambda,x_0) = \frac{1}{1+\exp( -\frac{s-x_0}{\lambda} ) }
!> @f]
!> Sin Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \sin(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Cos Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \cos(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!>
!> In all of the function form @f$\lambda@f$ controls the width of the transition and @f$x_0@f$ the transition point. 
!> 
!> After fitting these to the bathymetric variable (H) we can introduce interaction. Allowing interaction terms for the 
!> spatial functions depending on bathymetry only we can define, @f$g_j(x,H,\lambda^j,{x_0}^j,\lambda_k,{x_0}^k)=f_j(x)f_k ( H )@f$
!> @f[
!> f(x,y,H)=\sum_i f_i(H,\lambda^i,z_0^i) + \sum_j f_{j_x}(x,\lambda^{j_x},x_0^{j_x}) f_k(z,\lambda^k,x_0^k)+ \sum_j f_{j_y}(y,\lambda^{j_y},x_0^{j_y}) f_k(z,\lambda^k,x_0^k)
!> @f]
!>
!> Here @f$z@f$ is bathymetric depth. We start by fitting nonlinear parameters @f$\lambda^{c,s}@f$ and @f$x_0^{c,s}@f$ to log 
!> recruitment for "cross shelf" structure.  
!> @f[
!> f(x,y,z)=\beta_0+\sum_i \beta_i f_i(z) + \sum_j \beta_j g_j(x,z)+\sum_k \beta_k g_k(y,z)+ \epsilon
!> @f]
!> where @f$\beta_i@f$ are coefficients for the spatial functions and @f$\epsilon@f$ is the zero mean noise process associated with UK.
!> 
!> @subsubsection m1p1p1p3 Fitting non-linear parameters
!> A brute force approach is taken to fitting the nonlinear parameters @f$x_0@f$ and @f$\lambda@f$.  A search range is 
!> determined based on the geographic range of the observations.  The parameters are then fit to minimize the misfit to 
!> observations. 
!>
!> Subroutine @a FitNLSFunc parameter np).  The nonlinear parameters are fit by minimizing RMS misfit to the simple least 
!> squares fit with a smoothness penalty,
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x= S(\lambda)@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are 
!> temporarily assigned (by least squares) constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ 
!> for all examples used here (see subroutine @a NLSFuncPen).  Other one dimensional function forms can be added to the 
!> software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!> A smoothness penalty is imposed for each function based on the analytic 
!> 
!> @subsection m1p1p2 Residual process
!> After performing an ordinary least squares fit for the SF coeficients, @f$\beta@f$, we have an estimate of @f$\epsilon@f$. 
!> An empirical variogram is computed subroutine @a variogramF, and variogram parameters are fit (again by brute force).  
!> The variogram forms allowed are "spherical", "exponential", and "gaussian".  The form is hard-coded in the main program, 
!> UniversalKriging.f90.
!>
!> @subsubsection m1p1p2p1 Posterior sampling
!> With the fitting of the residual we have a covariance for @f$\epsilon@f$ and the estimation problem becomes one of 
!> Generalized Least Squares (GLS).  Posterior sampling is then conducted  achieved posterior sampling is Treating the TBD
!>
!> @section m1p2 Non Linear Spatial function fitting for UK
!> The universal kriging algorithm described above is used to build a distribution based on the historical recruitment data 
!> (1979-present).  Spatial function forms of one variable were selected for smoothness and boundedness. We have:\n
!> Gaussian bump
!> 
!> The nonlinear parameters are fit by minimizing RMS misfit to the simple least squares fit. 
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are temporarily 
!> assigned constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ for all examples used here.  
!> Other one dimensional function forms can be added to the software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!-----------------------------------------------------------------------
program UKsimulation
use globals
use GridManagerMod
use LinearSpatialFcnMod
use NonLinearSpatialFcnMod
use KrigMod
USE RandomFieldMod
implicit none

real(dp)  atmp, btmp
real(dp), allocatable :: beta(:), Cbeta(:,:), eps(:), Ceps(:,:), Cr(:,:), F(:,:), r(:), trndOBS(:), resOBS(:)
real(dp), allocatable :: Dh(:,:), Dz(:,:), gamma(:,:), Veps(:), VSpFn(:), CbetaF(:,:), Fg(:,:)
real(dp), allocatable :: ClimEst(:), ClimEstObs(:), trend(:), Vtotal(:), logmu(:)
real(dp), allocatable :: RandomField(:,:)
integer      nn, nf, no, SimType, j, nits
real(dp)     tmp(1, 1), fmax, A, DomainAverage, SF
! variables for nonlinear fitting
integer nsf, NRand, ncla
logical IsClimEst, IsHiLimit, IsMatchMean, IsLogT
character(72) obsfile, climfile
character(2) DomainName
type(Grid_Data_Class):: grid
type(Grid_Data_Class):: obs
type(KrigPar):: par
type(NLSFPar), allocatable ::nlsf(:)
real(dp) alpha
par%form='spherical'
IsLogT=.true.
IsHiLimit=.true.
IsClimEst=.false.
IsMatchMean=.true.
alpha=1.D0

write (*,*) "PROGRAM STARTING"

call ReadInput(DomainName, obsfile, climfile, Nrand, IsLogT, IsHiLimit, fmax, IsMatchMean, IsClimEst, par, alpha)
!override UK.inp with command line arguments if present
ncla=command_argument_count()
if(ncla.ge.1)call get_command_argument(1, DomainName)
if(ncla.ge.2)call get_command_argument(2, obsfile)
if(ncla.ge.3)call get_command_argument(3, climfile)
if(ncla.ge.3)IsClimEst=.true.

write (*,*) "Reading ", DomainName

write(*,*)'observation file:  ', trim(obsfile)
if(IsClimEst) write(*,*)'clim file:  ', trim(climfile)
write(*,*)'Logtransorm', IsLogT
write(*,*)'Match stratified sampling estimate', IsMatchMean
write(*,*)'high limit fmax', fmax
write(*,*)par%form
call random_seed( )
!SimType=0 !priori simulation
SimType=1 !posterior simulation
! Initalize number of spatial functions nf with dummy call to spatial_function
allocate(nlsf(1:1))
call DefineNLSFunctions(nlsf, obs, .true.)
nsf=nlsf(1)%nsf
deallocate(nlsf)
allocate(nlsf(1:nsf))
nlsf(1:nsf)%nsf=nsf
call spatial_function(grid, tmp, nf, 1, nlsf)
!
! Initalize grid point coordinates and bathymetry - initialize nn
!
call Load_Grid(grid%x, grid%y, grid%z, grid%lat, grid%lon, grid%n, &
              grid%E, grid%ne, grid%ManagementRegion, DomainName)
nn=grid%n
!
! Initalize number of spatial functions nf with dummy call to spatial_function
!
allocate( beta(1:nf), Cbeta(1:nf, 1:nf), eps(1:nn), Ceps(1:nn, 1:nn), CbetaF(1:nf, 1:nn))
allocate( Veps(1:nn), VSpFn(1:nn), Fg(1:nn, 1:nf), trend(1:nn), Vtotal(1:nn), logmu(1:nn))
allocate( RandomField(1:nn, 1:Nrand))
if (SimType.eq.1) then
    !
    ! Initalize data point coordinates, bathymetry and data - initialize no
    !
    call Load_Data(obs%x, obs%y, obs%z, obs%f, obs%n, trim(obsfile))
    no=obs%n
    nsf=nlsf(1)%nsf
    nlsf(1:nsf)%nsflim=nsf
    obs%f(1:no)=obs%f(1:no)**alpha

    write(*,*)'no=', no, 'nsf limit=', nlsf(1)%nsflim, 'nsf=', nlsf(1)%nsf
    !-------------------------------------------------------------------------  
    ! nonlinear curve fitting for spatial functions
    !-------------------------------------------------------------------------  
    call DefineNLSFunctions(nlsf, grid, .false.)
    !nlsf(1:nsf)%nsf=NSpatFunLim
    nsf=nlsf(1)%nsf
    
    allocate( Cr(1:no, 1:no), F(1:no, 1:nf), r(1:no), trndOBS(1:no), resOBS(1:no))
    allocate( Dh(1:no, 1:no), Dz(1:no, 1:no), gamma(1:no, 1:no) )
    !fmax=1.5*maxval(obs%f(1:no))
    fmax=fmax*maxval(obs%f(1:no))
    call Get_Domain_Average(obs, grid, DomainAverage)

    if(IsLogT) then
        A = 1.D0 / tow_area_sqm ! 1 scallop per tow 
        SF=sum(obs%f(1:no))/float(no)
        SF=SF/5.D0  ! mean / 5 ~ median
        obs%f(1:no)=log(( A+obs%f(1:no) )/SF)
    endif
    
    if(IsClimEst)then
        allocate(ClimEst(1:nn), ClimEstObs(1:no))
        write(*,*)'ClimFile=', climfile
        call readsf(climfile, ClimEst, j)
        ClimEst(1:nn)=ClimEst(1:nn)**alpha
        call WriteScalarField(nn, ClimEst(1:nn), 'ClimEstField.txt')
        write(*,*)'climatology: read nn=', j, 'values from ', trim(ClimFile)
        if (IsLogT)ClimEst(1:nn)=log(A+ClimEst(1:nn))
        call Interpret_From_Grid(grid, ClimEst, obs, ClimEstObs)
        call WriteScalarField(no, ClimEstObs(1:no), 'ClimEstObs.txt')
        call WriteScalarField(no, obs%f(1:no), 'RawObs.txt')
        obs%f(1:no)=obs%f(1:no)-ClimEstObs(1:no)
        call WriteScalarField(no, obs%f(1:no), 'AdjObs.txt')
    endif

    if (nlsf(1)%UseGreedyFit.eq.1) call FitNLSFunctionsGreedy(obs, nlsf)
    if (nlsf(1)%UseGreedyFit.eq.0) call FitNLSFunctions(obs, nlsf, 0)
    nsf=nlsf(1)%nsf
    do j=1, nlsf(1)%nsf
        write(*,*)nlsf(j)%d, ' ', nlsf(j)%form, nlsf(j)%x0, nlsf(j)%lambda
    enddo

    !-------------------------------------------------------------------------
    ! OLS fit with spatial functions
    !-------------------------------------------------------------------------
    Cr(1:no, 1:no)=0.D0
    do j=1, no
        Cr(j, j)=1.D0
    enddo
    call spatial_function(obs, F, nf, no, nlsf)
    call GLS(obs%f, F, Cr, no, nf, beta, Cbeta, r)
    write(*,*)'OLSres:', sqrt(sum(r(1:no)**2)/float(no))

    !-------------------------------------------------------------------------
    ! Fit variogram parameters to OLS residual
    !-------------------------------------------------------------------------
    call WriteScalarField(no, r, 'OLSresidual.txt')
    call WriteScalarField(no, obs%f, 'data.txt')
    call distance(obs, obs, Dh, Dz, no)
    nits=1
    do j=1, nits
        call variogramF(no, Dh, Dz, Gamma, no, r, par)
        open(63, file='KRIGpar.txt')
        write(63,*)par%c, par%c0, par%alpha, par%Wz
        close(63)

        !-------------------------------------------------------------------------
        ! Compute Universal Kriging estimate of field on grid (fest) given
        ! observations xo, yo, zo, fo. Also returns the estimate of spatial function
        ! coeficients, beta, and posterior covariance of beta(Cbeta).
        !-------------------------------------------------------------------------
        call UK_GLS(grid, obs, nf, par, beta, Cbeta, eps, Ceps, nlsf)
        call spatial_function(obs, F, nf, no, nlsf)
        atmp=1.D0
        btmp=0.D0
        call dgemv('N', no, nf, atmp, F, no, beta, 1, btmp, trndOBS, 1)
        resOBS(1:no)=obs%f(1:no)-trndOBS(1:no)
        write(*,*)'GLSres:', sqrt(sum(resOBS(1:no)**2)/float(no))
    enddo
else 
    ! simulate from user supplied prior estimate of beta, Cbeta, eps, Ceps
    call UK_prior(grid, nf, par, beta, Cbeta, eps, Ceps)
endif

call OutputUK(nn, nf, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, ClimEst, fmax, SF, A, DomainAverage, &
&                    IsLogT, IsClimEst, IsMatchMean, IsHiLimit, DomainName, alpha)

call Interpret_From_Grid(grid, grid%f, obs, r)
r(1:no)=r(1:no)**(1./alpha)
call WriteScalarField(no, r, 'KrigAtObs.txt')

deallocate( Dh, Dz, beta, Cbeta, Ceps, r)

stop
endprogram

!---------------------------------------------------------------------------------------------------
!> Purpose: This subroutine writes files for output.  This includes a central prediction: 
!> "KrigingEstimate.txt" and random fields generated from the posterior distribution:
!> "RandomFieldN.txt", where N =1:Nrand. Predictor standard deviation  is output to "KrigSTD.txt".
!> Function coefficient 
!---------------------------------------------------------------------------------------------------
subroutine OutputUK(nn, nf, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, ClimEst, fmax, SF, A, DomainAverage, &
    IsLogT, IsClimEst, IsMatchMean, IsHiLimit, DomainName, alpha)
use GridManagerMod
use NonLinearSpatialFcnMod
use KrigMod
implicit none

type(Grid_Data_Class), intent(inout) :: grid
type(NLSFPar), intent(in)::nlsf(*)
                                    
character(2) DomainName
integer, intent(in) :: nn, nf, Nrand
real(dp), intent(in) :: eps(*), beta(*), Cbeta(nf,*), ClimEst(*), fmax, SF, A, DomainAverage, alpha
real(dp), intent(inout) :: Ceps(nn,*)
logical, intent(in) ::IsLogT, IsClimEst, IsMatchMean, IsHiLimit
integer j, k, n
real(dp) trend(nn), V(nn), Fg(nn, nf), MuY, EnsMu, EnsSTD, logf(nn), adj, RandomField(nn, Nrand)
character(72) buf
integer nf_tmp
write(*,*)'output fmax, SF, A=', fmax, SF, A
do n=1, nn
    V(n)=Ceps(n, n)
enddo
grid%f(1:nn)=grid%f(1:nn)**(1./alpha)
if(IsClimEst)grid%f(1:nn)=grid%f(1:nn)+ClimEst(1:nn)**(1./alpha)
logf(1:nn)=grid%f(1:nn)
if(IsLogT) grid%f(1:nn)=SF*exp( grid%f(1:nn) + V(1:nn)/2. ) - A  ! adjusted inverse log(A+f)
if(IsHiLimit)call limitz(nn, grid%f, grid%z, fmax, DomainName)
MuY=sum( grid%f(1:nn) )/float(nn)
if(IsMatchMean)grid%f(1:nn)=DomainAverage*grid%f(1:nn)/MuY
if(IsHiLimit)call limitz(nn, grid%f, grid%z, fmax, DomainName)
call WriteScalarField(nn, grid%f, 'KrigingEstimate.txt')

call spatial_function(grid, Fg, nf_tmp, nn, nlsf)
trend(1:nn)=matmul( Fg(1:nn, 1:nf), beta(1:nf)) 
if(IsClimEst)trend(1:nn)=trend(1:nn)+ClimEst(1:nn)
if(IsLogT)trend(1:nn)=SF*exp(trend(1:nn))-A
if(IsMatchMean)trend(1:nn)=DomainAverage*trend(1:nn)/MuY
call WriteScalarField(nn, trend, 'SpatialTrend.txt')

call WriteScalarField(nn, eps, 'epsilon.txt')
call WriteScalarField(nf, beta, 'beta.txt')

call write_csv(nf, nf, Cbeta, 'CovBeta.csv', nf)

call spatial_function(grid, Fg, nf_tmp, nn, nlsf)
Ceps(1:nn, 1:nn)=Ceps(1:nn, 1:nn)+matmul( Fg(1:nn, 1:nf) , matmul(Cbeta(1:nf, 1:nf), transpose(Fg(1:nn, 1:nf)) ) )
do n=1, nn
 V(n)=Ceps(n, n)
enddo
if(IsLogT)call WriteScalarField(nn, SF*exp(sqrt(V(1:nn)))-A, 'KrigSTD.txt')
if(.not.IsLogT)call WriteScalarField(nn, sqrt(V(1:nn)), 'KrigSTD.txt')

if(IsLogT)call RandomSampleF(nn, nn, NRand, logf(1:n), Ceps, RandomField)
if(.not.IsLogT)call RandomSampleF(nn, nn, NRand, grid%f(1:n)**alpha, Ceps, RandomField)
RandomField(1:nn, 1:Nrand)=RandomField(1:nn, 1:Nrand)**(1./alpha)
do k=1, nn
    if(IsLogT)adj=SF*exp(sqrt(V(k)))-A
    if(.not.IsLogT)adj=sqrt(V(k))
    EnsMu=sum(  RandomField(k, 1:Nrand) )/float(Nrand)
    EnsSTD=sqrt( sum( ( RandomField(k, 1:Nrand)-EnsMu )**2 )/float(Nrand) )
    if(EnsSTD.gt.0.)then
        RandomField(k, 1:Nrand) = grid%f(k) +( RandomField(k, 1:Nrand) - EnsMu )*adj/EnsSTD
    else
        RandomField(k, 1:Nrand) = grid%f(k) + RandomField(k, 1:Nrand) - EnsMu 
    endif
    if(IsHiLimit)call limitz(Nrand, RandomField(k, 1:NRand), grid%z(k)+0.*RandomField(k, 1:NRand), &
                            fmax, DomainName)
enddo

!call write_csv(nn, NRand, RandomField, 'RandomField.csv', nn)
do j=1, Nrand
    write(buf, '(I6)')j
    call WriteScalarField(nn, RandomField(1:nn, j), 'RandomField'//trim(adjustl(buf))//'.txt')
enddo

return
end

