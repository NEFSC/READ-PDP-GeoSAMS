!--------------------------------------------------------------------------------------------------
!> @mainpage Universal Kriging
!>
!> Purpose: This program is designed to simulate random fields under the assumptions of Universal 
!> Kriging (UK).  It is assumed that the underlying spatial field is a linear combination of known 
!> spatial functions and a stationary zero mean random field with known variogram parameters.  The 
!> program can be configured in two ways:
!>
!> (1) To simulate random fields conditioned on the assumed UK model and a set of observations.
!>     (postrior simulation).
!>
!> (0) To simulate random fields based on specified mean spatial coefficients, their covariance
!>     and known variogram with known parameters (prior simulation).
!>
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!> 
!> @section m1p1 Implementation of random recruitment
!> Spatial fields of recruitment are generated by the software located in directory "/UKsrc".  The output files, such as:
!> "RecruitField/RecruityyyyMA/RandomFieldxx.txt" contain @f$n_{nodes}@f$ vectors of independent random fields conditioned on 
!> survey observations from "Data/RecruitsyyyyMA.csv", where xx runs from @f$1@f$ to @f$Nrand@f$ and @f$yyyy@f$ 1979 to 2018.
!>
!> @subsection m1p1p1 Interpolation Algorithm
!> The interpolation of recruit data is carried out with a Universal Kriging (UK) algorithm allowing for sampling from the posterior distribution. 
!>
!> @subsubsection m1p1p1p1 Universal Kriging
!> Universal kriging (UK) is a generalization of ordinary kriging in which a set of spatial functions are used to model the
!> trend of a set of point observations.  The underlying model is:
!> @f[
!> f(x,y,H(x,y),\lambda)=\sum_{k=1}^{n_f} f_k(x,y,H(x,y),\lambda_k) +\epsilon(x,y) 
!> @f] 
!> where @f$f_k@f$ are the known spatial functions and @f$\epsilon(x,y)@f$ is a zero mean, spatially correlated,  stationary random 
!> process with semi-variogram @f$\gamma(s)@f$. For a summary of UK see Cressie 1993, pages 151 -180.\n
!> % The spatially variable @f$x@f$ here is taken to include latitude, longitude and, bathymetric depth(@f$x=[lat,lon,z(lat,lon)]@f$). 
!> 
!> @subsubsection m1p1p1p2 Spatial functions
!> The spatial functions (SF) used here are  a set of one dimensional, bounded, C-infinity functions with two parameters, 
!> 
!> Gaussian Bump:
!> @f[
!> f_a (s,\lambda,x_0) = \exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Logistic curve:
!> @f[
!> f_b (s,\lambda,x_0) = \frac{1}{1+\exp( -\frac{s-x_0}{\lambda} ) }
!> @f]
!> Sin Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \sin(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Cos Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \cos(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!>
!> In all of the function form @f$\lambda@f$ controls the width of the transition and @f$x_0@f$ the transition point. 
!> 
!> After fitting these to the bathymetric variable (H) we can introduce interaction. Allowing interaction terms for the 
!> spatial functions depending on bathymetry only we can define, @f$g_j(x,H,\lambda^j,{x_0}^j,\lambda_k,{x_0}^k)=f_j(x)f_k ( H )@f$
!> @f[
!> f(x,y,H)=\sum_i f_i(H,\lambda^i,z_0^i) + \sum_j f_{j_x}(x,\lambda^{j_x},x_0^{j_x}) f_k(z,\lambda^k,x_0^k)+ \sum_j f_{j_y}(y,\lambda^{j_y},x_0^{j_y}) f_k(z,\lambda^k,x_0^k)
!> @f]
!>
!> Here @f$z@f$ is bathymetric depth. We start by fitting nonlinear parameters @f$\lambda^{c,s}@f$ and @f$x_0^{c,s}@f$ to log 
!> recruitment for "cross shelf" structure.  
!> @f[
!> f(x,y,z)=\beta_0+\sum_i \beta_i f_i(z) + \sum_j \beta_j g_j(x,z)+\sum_k \beta_k g_k(y,z)+ \epsilon
!> @f]
!> where @f$\beta_i@f$ are coefficients for the spatial functions and @f$\epsilon@f$ is the zero mean noise process associated with UK.
!> 
!> @subsubsection m1p1p1p3 Fitting non-linear parameters
!> A brute force approach is taken to fitting the nonlinear parameters @f$x_0@f$ and @f$\lambda@f$.  A search range is 
!> determined based on the geographic range of the observations.  The parameters are then fit to minimize the misfit to 
!> observations. 
!>
!> Subroutine @a NLSF_Fit_Function parameter np).  The nonlinear parameters are fit by minimizing RMS misfit to the simple least 
!> squares fit with a smoothness penalty,
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x= S(\lambda)@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are 
!> temporarily assigned (by least squares) constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ 
!> for all examples used here (see subroutine @a NLSF_Smooth_Penalty).  Other one dimensional function forms can be added to the 
!> software in subroutine @a NLSF_Evaluate_Fcn and @a NLSFFuncPen.
!> 
!> A smoothness penalty is imposed for each function based on the analytic 
!> 
!> @subsection m1p1p2 Residual process
!> After performing an ordinary least squares fit for the SF coeficients, @f$\beta@f$, we have an estimate of @f$\epsilon@f$. 
!> An empirical variogram is computed subroutine @a Krig_Comp_Emp_Variogram, and variogram parameters are fit (again by brute force).  
!> The variogram forms allowed are "spherical", "exponential", and "gaussian".  The form is hard-coded in the main program, 
!> UniversalKriging.f90.
!>
!> @subsubsection m1p1p2p1 Posterior sampling
!> With the fitting of the residual we have a covariance for @f$\epsilon@f$ and the estimation problem becomes one of 
!> Generalized Least Squares (LSF_Generalized_Least_Squares).  Posterior sampling is then conducted  achieved posterior sampling is Treating the TBD
!>
!> @section m1p2 Non Linear Spatial function fitting for UK
!> The universal kriging algorithm described above is used to build a distribution based on the historical recruitment data 
!> (1979-present).  Spatial function forms of one variable were selected for smoothness and boundedness. We have:\n
!> Gaussian bump
!> 
!> The nonlinear parameters are fit by minimizing RMS misfit to the simple least squares fit. 
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are temporarily 
!> assigned constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ for all examples used here.  
!> Other one dimensional function forms can be added to the software in subroutine @a NLSF_Evaluate_Fcn and @a NLSFFuncPen.
!> 
!-----------------------------------------------------------------------
program UKsimulation
use globals
use GridManagerMod
use LSF_Mod
use NLSF_Mod
use Krig_Mod
USE RandomFieldMod
implicit none

real(dp)  atmp, btmp
real(dp), allocatable :: beta(:), Cbeta(:,:), eps(:), Ceps(:,:), Cr(:,:), F(:,:), r(:), trndOBS(:), resOBS(:)
real(dp), allocatable :: distance_horiz(:,:), distance_vert(:,:), gamma(:,:)
real(dp), allocatable :: RandomField(:,:)
integer num_points, num_spat_fcns, num_obs_points, j
logical use_posterior_sim ! # F priori simulation, T posterior simulation
real(dp)  fmax, A, SF!, domain_average Deprecate domain_average
! variables for nonlinear fitting
integer nsf, NRand, ncla
logical IsHiLimit, IsLogT!, IsMatchMean
character(fname_len) cfg_file_name
character(fname_len) obsfile, cmd
character(2) domain_name
logical exists
type(Grid_Data_Class):: grid
type(Grid_Data_Class):: obs
type(Krig_Class):: par
type(NLSFPar), allocatable ::nlsf(:)
real(dp) alpha
par%form='spherical'

write (*,*) term_grn, "PROGRAM STARTING", term_blk

ncla=command_argument_count()
if (ncla .eq. 0) then
    write(*,*) term_red, 'No UK configuration file given', term_blk
    call get_command(cmd)
    write(*,*) term_blu,'Typical use: $ ', term_yel, trim(cmd), ' UK.cfg', term_blk
    stop
endif

if(ncla.ge.1) call get_command_argument(1, cfg_file_name)
cfg_file_name = config_dir//trim(cfg_file_name)
inquire(file=cfg_file_name, exist=exists)
if (exists) then
    PRINT *, term_blu, trim(cfg_file_name), ' FOUND', term_blk
else
    PRINT *, term_red, trim(cfg_file_name), ' NOT FOUND', term_blk
    stop
endif

call Read_Startup_Config(cfg_file_name, domain_name, use_posterior_sim, Nrand, IsLogT, IsHiLimit, fmax, par, alpha) !, IsMatchMean
!override UK.cfg with command line arguments if present. Used by python scripts
if(ncla.ge.2) call get_command_argument(2, domain_name)
if (.not. ( any ((/ domain_name.eq.'MA', domain_name.eq.'GB'/)) )) then
    write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', domain_name, term_blk
    stop
endif

if(ncla.ge.3) then
    call get_command_argument(3, obsfile)
    call Set_Obs_Data_File_Name(obsfile)
endif

write (*,*) term_blu,"Reading ", domain_name

write(*,*) 'Observation file:  ', Get_Obs_Data_File_Name()
write(*,*) 'Logtransorm', IsLogT
!write(*,*) 'Match stratified sampling estimate', IsMatchMean ! DEPRECATE
write(*,*) 'High limit fmax', fmax
write(*,*) 'Form of variagram: ', par%form
if (.not. use_posterior_sim) write(*,*) 'use_posterior_sim is priori simulation'
if (use_posterior_sim) write(*,*) 'use_posterior_sim is posterior simulation'
write(*,*) term_blk

call random_seed( )

! Determine how many spatial functions are defined.
allocate(nlsf(1:1))
nsf = NLSF_Define_Functions(nlsf, obs, .true.)
deallocate(nlsf)

num_spat_fcns = nsf + 1
allocate( beta(1:num_spat_fcns), Cbeta(1:num_spat_fcns, 1:num_spat_fcns) )
allocate(nlsf(1:nsf))

!
! Initalize grid point coordinates and bathymetry - initialize num_points
!
num_points = Load_Grid(grid%x, grid%y, grid%z, grid%lat, grid%lon)!, grid%ManagementRegion) Deprecate
grid%num_points = num_points

allocate( eps(1:num_points), Ceps(1:num_points, 1:num_points))
allocate( RandomField(1:num_points, 1:Nrand))

if (use_posterior_sim) then
    !
    ! Initalize data point coordinates, bathymetry and data - initialize no
    !
    obs%num_points = Load_Observation_Data(obs%x, obs%y, obs%z, obs%field_psqm)
    num_obs_points=obs%num_points
    obs%field_psqm(1:num_obs_points)=obs%field_psqm(1:num_obs_points)**alpha

    !-------------------------------------------------------------------------  
    ! nonlinear curve fitting for spatial functions
    !-------------------------------------------------------------------------  
    nsf = NLSF_Define_Functions(nlsf, grid, .false.)
    !nlsf(1:nsf)%nsflim = nsf

    write(*,*)'num_obs_points=', num_obs_points, 'nsf limit=', Get_NSF_Limit()
    write(*,'(A, A, A, I2, A, A)') term_blu, 'Using ', term_blk, nsf, term_blu, ' Spatial Functions'
    write(*,'(A,L2)') 'Is Truncate Range: ', Get_Is_Truncate_Range()
    write(*,'(A,L2)') 'Using Greedy Fit:  ', Get_Use_Greedy_Fit(), term_blk
    
    allocate( Cr(1:num_obs_points, 1:num_obs_points), F(1:num_obs_points, 1:num_spat_fcns), r(1:num_obs_points))
    allocate( trndOBS(1:num_obs_points), resOBS(1:num_obs_points))
    allocate( distance_horiz(1:num_obs_points, 1:num_obs_points), distance_vert(1:num_obs_points, 1:num_obs_points))
    allocate( gamma(1:num_obs_points, 1:num_obs_points) )

    fmax = fmax * maxval(obs%field_psqm(1:num_obs_points))
    !domain_average = Get_Domain_Average(obs, grid)

    if(IsLogT) then
        A = 1.D0 / tow_area_sqm ! 1 scallop per tow, prevents log(0)
        SF = sum(obs%field_psqm(1:num_obs_points))/float(num_obs_points)
        SF = SF/5.D0  ! mean / 5 ~ median
        obs%field_psqm(1:num_obs_points) = log((A + obs%field_psqm(1:num_obs_points)) / SF)
    endif
    
    call NLSF_Select_Fit(obs, nlsf)
    do j=1, nsf
        write(*,*)nlsf(j)%axis, ' ', nlsf(j)%form, nlsf(j)%f0, nlsf(j)%lambda
    enddo

    !-------------------------------------------------------------------------
    ! OLS fit with spatial functions
    !-------------------------------------------------------------------------
    Cr(1:num_obs_points, 1:num_obs_points)=0.D0
    do j=1, num_obs_points
        Cr(j, j)=1.D0
    enddo
    call Krig_Evaluate_Spatial_Function(obs, F, num_spat_fcns, num_obs_points, nlsf)
    call LSF_Generalized_Least_Squares(obs%field_psqm, F, Cr, num_obs_points, num_spat_fcns, beta, Cbeta, r)
    write(*,*)'OLSres:', sqrt(sum(r(1:num_obs_points)**2)/float(num_obs_points))

    !-------------------------------------------------------------------------
    ! Fit variogram parameters to OLS residual
    !-------------------------------------------------------------------------
    call Write_Vector_Scalar_Field(num_obs_points, r, 'OLSresidual.txt')
    call Write_Vector_Scalar_Field(num_obs_points, obs%field_psqm, 'data.txt')
    call Krig_Compute_Distance(obs, obs, distance_horiz, distance_vert, num_obs_points)

    call Krig_Comp_Emp_Variogram(num_obs_points, distance_horiz, distance_vert, gamma, num_obs_points, r, par)
    open(63, file='KRIGpar.txt')
    write(63,*)par%sill, par%nugget, par%alpha, par%Wz
    close(63)

    !-------------------------------------------------------------------------
    ! Compute Universal Kriging estimate of field on grid (fest) given
    ! observations x_obs, y_obs, z_obs, field_obs. Also returns the estimate of spatial function
    ! coeficients, beta, and posterior covariance of beta(Cbeta).
    !-------------------------------------------------------------------------
    call Krig_Generalized_Least_Sq(grid, obs, num_spat_fcns, par, beta, Cbeta, eps, Ceps, nlsf)
    call Krig_Evaluate_Spatial_Function(obs, F, num_spat_fcns, num_obs_points, nlsf)
    atmp=1.D0
    btmp=0.D0
    call dgemv('N', num_obs_points, num_spat_fcns, atmp, F, num_obs_points, beta, 1, btmp, trndOBS, 1)
    resOBS(1:num_obs_points) = obs%field_psqm(1:num_obs_points) - trndOBS(1:num_obs_points)
    write(*,*)'GLSres:', sqrt(sum(resOBS(1:num_obs_points)**2) / float(num_obs_points))
else 
    ! simulate from user supplied prior estimate of beta, Cbeta, eps, Ceps
    call UK_prior(grid, num_spat_fcns, par, beta, Cbeta, eps, Ceps)
endif

! Deprecate domain_average IsMatchMean
! call OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, A, domain_average, &
! &                    IsLogT, IsMatchMean, IsHiLimit, domain_name, alpha)  
call OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, A, &
&                    IsLogT, IsHiLimit, domain_name, alpha)

write(*,*)'num_points, num_survey', num_points, num_obs_points

deallocate( beta, Cbeta, nlsf)
deallocate( eps, Ceps)
deallocate( RandomField)

if (use_posterior_sim) then
    deallocate( Cr, F, r)
    deallocate( trndOBS, resOBS)
    deallocate( distance_horiz, distance_vert)
    deallocate( gamma)
endif

stop
endprogram

!--------------------------------------------------------------------------------------------------
!> Purpose: Read parameter values, flags, etc. from an ascii text input file:"UK.cfg".  Parameters etc. 
!> to be read from UK.cfg are identified by tag before '='.  Values are read from the 
!> line to the right of an "=" character. Logical variables are read from 'T','F'.
!>
!> outputs: 
!>       all variables
!>
!--------------------------------------------------------------------------------------------------
! Keston Smith, Tom Callaghan (IBSS) 2024
!--------------------------------------------------------------------------------------------------
subroutine Read_Startup_Config(cfg_file_name, domain_name, use_posterior_sim, NRand, IsLogT, IsHiLimit, fmax, par, alpha)
use globals
use Krig_Mod
use NLSF_Mod, only : NLS_Set_Config_File_Name => Set_Config_File_Name
implicit none
character(*), intent(in) :: cfg_file_name
character(2),intent(out):: domain_name
logical, intent(out) :: use_posterior_sim
type(Krig_Class), intent(out):: par
integer j, k, io
integer, intent(out):: NRand

logical IsLogT,IsHiLimit! ,IsMatchMean
character(72) :: input_string
character(tag_len) tag
character(value_len) value
real(dp),intent(out)::  fmax,alpha

! set default values for parameters not in file
IsLogT=.true.
IsHiLimit=.false.
!IsMatchMean=.true.
alpha=1.D0
use_posterior_sim = .true.

open(69,file=cfg_file_name)
do
    input_string=""
    read(69,'(a)',iostat=io) input_string
    if (io.lt.0) exit

    if (input_string(1:1) .NE. '#') then
        j = scan(input_string,"=",back=.true.)
        tag = trim(adjustl(input_string(1:j-1)))
        ! explicitly ignore inline comment
        k = scan(input_string,"#",back=.true.)
        if (k .EQ. 0) k = len(input_string) + 1
        value =  trim(adjustl(input_string(j+1:k-1)))

        select case (tag)
        case('Domain Name')
            domain_name = value(1:2)
            if (.not. ( any ((/ domain_name.eq.'MA', domain_name.eq.'GB'/)) )) then
                write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', domain_name, term_blk
                stop
            endif

        case('Observation File')
            Call Set_Obs_Data_File_Name(value)

        case('Log Transform')
            read(value,*) IsLogT

        case('High Limit Factor')
            read(value, *) fmax

        case('Power Transform Parameter')
            if (IsLogT) then
                ! Forcing alpha to 1.0
                alpha=1.D0
                write(*,*) term_yel, 'Log Transform is T, ignoring Power Transform Param', term_blk
            else
                read(value,*) alpha
                IsHiLimit = .true.
                write(*,*)'Is this the fmax you were searching for?', fmax
            endif

        case('Number of Random Fields')
            read( value,*) NRand

        case('Kriging variogram form')
            read(value,*) par%form

        ! DEPRECATE
        ! case('Match stratified mean')
        !     read(value,*) IsMatchMean

        case('Use Posterior Sim')
            read(value,*) use_posterior_sim

        case('Grid File Name')
            if (domain_name .ne. value(1:2)) then
                write (*,*) term_red, 'Domain Name Mismatch: Expecting ', term_blk, domain_name, term_red, &
                &  ' read ', term_blk, value(1:2)
                stop
            endif
            Call Set_Grid_Data_File_Name(value)

        case('NLS Spatial Fcn File Name')
            call NLS_Set_Config_File_Name(value)

        case default
            write(*,*) term_yel, 'ReadInput: Unrecognized line in UK.cfg'
            write(*,*) 'Unrecognized Line->',input_string
            write(*,*) 'This is probably not a problem', term_blk
            !stop
    end select
    endif
end do
close(69)
endsubroutine Read_Startup_Config
        
!---------------------------------------------------------------------------------------------------
!> Purpose: This subroutine writes files for output.  This includes a central prediction: 
!> "KrigingEstimate.txt" and random fields generated from the posterior distribution:
!> "RandomFieldN.txt", where N =1:Nrand. Predictor standard deviation  is output to "KrigSTD.txt".
!> Function coefficient 
!---------------------------------------------------------------------------------------------------
subroutine OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, A, &!domain_average, , IsMatchMean
&                  IsLogT, IsHiLimit, domain_name, alpha)
use GridManagerMod
use NLSF_Mod
use Krig_Mod
implicit none

type(Grid_Data_Class), intent(inout) :: grid
type(NLSFPar), intent(in)::nlsf(*)
                                    
character(2) domain_name
integer, intent(in) :: num_points, num_spat_fcns, Nrand
real(dp), intent(in) :: eps(*), beta(*), Cbeta(num_spat_fcns,*), fmax, SF, A, alpha !domain_average
real(dp), intent(inout) :: Ceps(num_points,*)
logical, intent(in) ::IsLogT, IsHiLimit
!logical, intent(in) ::IsMatchMean ! Deprecate
integer j, k, n
real(dp) trend(num_points), V(num_points), Fg(num_points, num_spat_fcns), EnsMu, EnsSTD ! , MuY ! Deprecate
real(dp) logf(num_points), adj, RandomField(num_points, Nrand)
character(72) buf

write(*,*)'output fmax, SF, A=', fmax, SF, A
do n=1, num_points
    V(n)=Ceps(n, n)
enddo
grid%field_psqm(1:num_points) = grid%field_psqm(1:num_points)**(1./alpha)

logf(1:num_points) = grid%field_psqm(1:num_points)
if(IsLogT) grid%field_psqm(1:num_points) = SF * exp( grid%field_psqm(1:num_points) + V(1:num_points)/2. ) - A  ! adjusted inverse log(A+f)
if(IsHiLimit) call LSF_Limit_Z(num_points, grid%field_psqm, grid%z, fmax, domain_name)
! MuY = sum( grid%field_psqm(1:num_points)) / float(num_points)
!if(IsMatchMean) grid%field_psqm(1:num_points) = domain_average * grid%field_psqm(1:num_points) / MuY ! Deprecate
if(IsHiLimit) call LSF_Limit_Z(num_points, grid%field_psqm, grid%z, fmax, domain_name)
call Write_Vector_Scalar_Field(num_points, grid%field_psqm, 'KrigingEstimate.txt')

call Krig_Evaluate_Spatial_Function(grid, Fg, num_spat_fcns, num_points, nlsf)
trend(1:num_points) = matmul( Fg(1:num_points, 1:num_spat_fcns), beta(1:num_spat_fcns)) 

if(IsLogT) trend(1:num_points) = SF*exp(trend(1:num_points))-A
!if(IsMatchMean) trend(1:num_points) = domain_average * trend(1:num_points) / MuY ! Deprecate
call Write_Vector_Scalar_Field(num_points, trend, 'SpatialTrend.txt')

call Write_Vector_Scalar_Field(num_points, eps, 'epsilon.txt')
call Write_Vector_Scalar_Field(num_spat_fcns, beta, 'beta.txt')

call write_csv(num_spat_fcns, num_spat_fcns, Cbeta, 'CovBeta.csv', num_spat_fcns)

call Krig_Evaluate_Spatial_Function(grid, Fg, num_spat_fcns, num_points, nlsf)
Ceps(1:num_points, 1:num_points) = Ceps(1:num_points, 1:num_points)&
&    + matmul( Fg(1:num_points, 1:num_spat_fcns) , &
&              matmul(Cbeta(1:num_spat_fcns, 1:num_spat_fcns), transpose(Fg(1:num_points, 1:num_spat_fcns)) ) )
do n=1, num_points
   V(n) = Ceps(n, n)
enddo
if(IsLogT) call Write_Vector_Scalar_Field(num_points, SF*exp(sqrt(V(1:num_points)))-A, 'KrigSTD.txt')
if(.not.IsLogT) call Write_Vector_Scalar_Field(num_points, sqrt(V(1:num_points)), 'KrigSTD.txt')

if(IsLogT) call RandomSampleF(num_points, num_points, NRand, logf(1:n), Ceps, RandomField)
if(.not.IsLogT) call RandomSampleF(num_points, num_points, NRand, grid%field_psqm(1:n)**alpha, Ceps, RandomField)
RandomField(1:num_points, 1:Nrand)=RandomField(1:num_points, 1:Nrand)**(1./alpha)
do k=1, num_points
    if(IsLogT) adj = SF * exp(sqrt(V(k))) - A
    if(.not.IsLogT) adj = sqrt(V(k))
    EnsMu = sum(RandomField(k, 1:Nrand)) / float(Nrand)
    EnsSTD = sqrt( sum((RandomField(k, 1:Nrand) - EnsMu)**2 ) / float(Nrand) )
    if(EnsSTD.gt.0.) then
        RandomField(k, 1:Nrand) = grid%field_psqm(k) +( RandomField(k, 1:Nrand) - EnsMu )*adj/EnsSTD
    else
        RandomField(k, 1:Nrand) = grid%field_psqm(k) + RandomField(k, 1:Nrand) - EnsMu 
    endif
    if(IsHiLimit) call LSF_Limit_Z(Nrand, RandomField(k, 1:NRand), grid%z(k)+0.*RandomField(k, 1:NRand), &
                            fmax, domain_name)
enddo

do j=1, Nrand
    write(buf, '(I6)')j
    call Write_Vector_Scalar_Field(num_points, RandomField(1:num_points, j), 'RandomField'//trim(adjustl(buf))//'.txt')
enddo
endsubroutine OutputUK
