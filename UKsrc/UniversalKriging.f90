!--------------------------------------------------------------------------------------------------
!> @mainpage Universal Kriging
!>
!> Purpose: This program is designed to simulate random fields under the assumptions of Universal 
!> Kriging (UK).  It is assumed that the underlying spatial field is a linear combination of known 
!> spatial functions and a stationary zero mean random field with known variogram parameters.  The 
!> program can be configured in two ways:
!>
!> (1) To simulate random fields conditioned on the assumed UK model and a set of observations.
!>     (postrior simulation).
!>
!> (0) To simulate random fields based on specified mean spatial coefficients, their covariance
!>     and known variogram with known parameters (prior simulation).
!>
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!> 
!> @section m1p1 Implementation of random recruitment
!> Spatial fields of recruitment are generated by the software located in directory "/UKsrc".  The output files, such as:
!> "RecruitField/RecruityyyyMA/RandomFieldxx.txt" contain @f$n_{nodes}@f$ vectors of independent random fields conditioned on 
!> survey observations from "Data/RecruitsyyyyMA.csv", where xx runs from @f$1@f$ to @f$Nrand@f$ and @f$yyyy@f$ 1979 to 2018.
!>
!> @subsection m1p1p1 Interpolation Algorithm
!> The interpolation of recruit data is carried out with a Universal Kriging (UK) algorithm allowing for sampling from the posterior distribution. 
!>
!> @subsubsection m1p1p1p1 Universal Kriging
!> Universal kriging (UK) is a generalization of ordinary kriging in which a set of spatial functions are used to model the
!> trend of a set of point observations.  The underlying model is:
!> @f[
!> f(x,y,H(x,y),\lambda)=\sum_{k=1}^{n_f} f_k(x,y,H(x,y),\lambda_k) +\epsilon(x,y) 
!> @f] 
!> where @f$f_k@f$ are the known spatial functions and @f$\epsilon(x,y)@f$ is a zero mean, spatially correlated,  stationary random 
!> process with semi-variogram @f$\gamma(s)@f$. For a summary of UK see Cressie 1993, pages 151 -180.\n
!> % The spatially variable @f$x@f$ here is taken to include latitude, longitude and, bathymetric depth(@f$x=[lat,lon,z(lat,lon)]@f$). 
!> 
!> @subsubsection m1p1p1p2 Spatial functions
!> The spatial functions (SF) used here are  a set of one dimensional, bounded, C-infinity functions with two parameters, 
!> 
!> Gaussian Bump:
!> @f[
!> f_a (s,\lambda,x_0) = \exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Logistic curve:
!> @f[
!> f_b (s,\lambda,x_0) = \frac{1}{1+\exp( -\frac{s-x_0}{\lambda} ) }
!> @f]
!> Sin Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \sin(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Cos Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \cos(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!>
!> In all of the function form @f$\lambda@f$ controls the width of the transition and @f$x_0@f$ the transition point. 
!> 
!> After fitting these to the bathymetric variable (H) we can introduce interaction. Allowing interaction terms for the 
!> spatial functions depending on bathymetry only we can define, @f$g_j(x,H,\lambda^j,{x_0}^j,\lambda_k,{x_0}^k)=f_j(x)f_k ( H )@f$
!> @f[
!> f(x,y,H)=\sum_i f_i(H,\lambda^i,z_0^i) + \sum_j f_{j_x}(x,\lambda^{j_x},x_0^{j_x}) f_k(z,\lambda^k,x_0^k)+ \sum_j f_{j_y}(y,\lambda^{j_y},x_0^{j_y}) f_k(z,\lambda^k,x_0^k)
!> @f]
!>
!> Here @f$z@f$ is bathymetric depth. We start by fitting nonlinear parameters @f$\lambda^{c,s}@f$ and @f$x_0^{c,s}@f$ to log 
!> recruitment for "cross shelf" structure.  
!> @f[
!> f(x,y,z)=\beta_0+\sum_i \beta_i f_i(z) + \sum_j \beta_j g_j(x,z)+\sum_k \beta_k g_k(y,z)+ \epsilon
!> @f]
!> where @f$\beta_i@f$ are coefficients for the spatial functions and @f$\epsilon@f$ is the zero mean noise process associated with UK.
!> 
!> @subsubsection m1p1p1p3 Fitting non-linear parameters
!> A brute force approach is taken to fitting the nonlinear parameters @f$x_0@f$ and @f$\lambda@f$.  A search range is 
!> determined based on the geographic range of the observations.  The parameters are then fit to minimize the misfit to 
!> observations. 
!>
!> Subroutine @a FitNLSFunc parameter np).  The nonlinear parameters are fit by minimizing RMS misfit to the simple least 
!> squares fit with a smoothness penalty,
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x= S(\lambda)@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are 
!> temporarily assigned (by least squares) constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ 
!> for all examples used here (see subroutine @a NLSFuncPen).  Other one dimensional function forms can be added to the 
!> software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!> A smoothness penalty is imposed for each function based on the analytic 
!> 
!> @subsection m1p1p2 Residual process
!> After performing an ordinary least squares fit for the SF coeficients, @f$\beta@f$, we have an estimate of @f$\epsilon@f$. 
!> An empirical variogram is computed subroutine @a Compute_Empirical_Variogram, and variogram parameters are fit (again by brute force).  
!> The variogram forms allowed are "spherical", "exponential", and "gaussian".  The form is hard-coded in the main program, 
!> UniversalKriging.f90.
!>
!> @subsubsection m1p1p2p1 Posterior sampling
!> With the fitting of the residual we have a covariance for @f$\epsilon@f$ and the estimation problem becomes one of 
!> Generalized Least Squares (GLS).  Posterior sampling is then conducted  achieved posterior sampling is Treating the TBD
!>
!> @section m1p2 Non Linear Spatial function fitting for UK
!> The universal kriging algorithm described above is used to build a distribution based on the historical recruitment data 
!> (1979-present).  Spatial function forms of one variable were selected for smoothness and boundedness. We have:\n
!> Gaussian bump
!> 
!> The nonlinear parameters are fit by minimizing RMS misfit to the simple least squares fit. 
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are temporarily 
!> assigned constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ for all examples used here.  
!> Other one dimensional function forms can be added to the software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!-----------------------------------------------------------------------
program UKsimulation
use globals
use GridManagerMod
use LinearSpatialFcnMod
use NonLinearSpatialFcnMod
use KrigMod
USE RandomFieldMod
implicit none

real(dp)  atmp, btmp
real(dp), allocatable :: beta(:), Cbeta(:,:), eps(:), Ceps(:,:), Cr(:,:), F(:,:), r(:), trndOBS(:), resOBS(:)
real(dp), allocatable :: distance_horiz(:,:), distance_vert(:,:), gamma(:,:), Veps(:), VSpFn(:), CbetaF(:,:), Fg(:,:)
real(dp), allocatable :: trend(:), Vtotal(:), logmu(:)
real(dp), allocatable :: RandomField(:,:)
integer   num_points, num_spat_fcns, num_obs_points, SimType, j
real(dp)  fmax, A, domain_average, SF
! variables for nonlinear fitting
integer nsf, NRand, ncla
logical IsHiLimit, IsMatchMean, IsLogT
character(72) obsfile
character(2) domain_name
type(Grid_Data_Class):: grid
type(Grid_Data_Class):: obs
type(KrigPar):: par
type(NLSFPar), allocatable ::nlsf(:)
real(dp) alpha
par%form='spherical'

write (*,*) term_grn, "PROGRAM STARTING", term_blk

call Read_Startup_Config(domain_name, SimType, obsfile, Nrand, IsLogT, IsHiLimit, fmax, IsMatchMean, par, alpha)
!override UK.inp with command line arguments if present
ncla=command_argument_count()
if(ncla.ge.1)call get_command_argument(1, domain_name)
if(ncla.ge.2)call get_command_argument(2, obsfile)

write (*,*) term_blu,"Reading ", domain_name

write(*,*) 'Observation file:  ', trim(obsfile)
write(*,*) 'Logtransorm', IsLogT
write(*,*) 'Match stratified sampling estimate', IsMatchMean
write(*,*) 'High limit fmax', fmax
write(*,*) 'Form of variagram: ', par%form
if (SimType .EQ. 0) write(*,*) 'SimType is priori simulation'
if (SimType .EQ. 1) write(*,*) 'SimType is posterior simulation'
write(*,*) term_blk

call random_seed( )

! Determine how many spatial functions are defined.
allocate(nlsf(1:1))
nsf = DefineNLSFunctions(nlsf, obs, .true.)
deallocate(nlsf)

num_spat_fcns = nsf + 1
allocate( beta(1:num_spat_fcns), Cbeta(1:num_spat_fcns, 1:num_spat_fcns) )
allocate(nlsf(1:nsf))
nlsf(1:nsf)%nsf=nsf

!
! Initalize grid point coordinates and bathymetry - initialize num_points
!
num_points = Load_Grid(grid%x, grid%y, grid%z, grid%lat, grid%lon, grid%ManagementRegion, domain_name)
grid%num_points = num_points

allocate( eps(1:num_points), Ceps(1:num_points, 1:num_points))
allocate( CbetaF(1:num_spat_fcns, 1:num_points))
allocate( Veps(1:num_points), VSpFn(1:num_points), Fg(1:num_points, 1:num_spat_fcns), trend(1:num_points))
allocate( Vtotal(1:num_points), logmu(1:num_points))
allocate( RandomField(1:num_points, 1:Nrand))

if (SimType.eq.1) then
    !
    ! Initalize data point coordinates, bathymetry and data - initialize no
    !
    obs%num_points = Load_Data(obs%x, obs%y, obs%z, obs%f_psqm, trim(obsfile))
    num_obs_points=obs%num_points
    obs%f_psqm(1:num_obs_points)=obs%f_psqm(1:num_obs_points)**alpha

    !-------------------------------------------------------------------------  
    ! nonlinear curve fitting for spatial functions
    !-------------------------------------------------------------------------  
    nsf = DefineNLSFunctions(nlsf, grid, .false.)
    nlsf(1:nsf)%nsflim=nsf

    write(*,*)'num_obs_points=', num_obs_points, 'nsf limit=', nlsf(1)%nsflim, 'nsf=', nlsf(1)%nsf
    write(*,'(A, A, A, I2, A, A)') term_blu, 'Using ', term_blk, nsf, term_blu, ' Spatial Functions'
    write(*,'(A,I2)') 'Using Truncate Range: ', nlsf(1)%IsTruncateRange
    write(*,'(A,I2)') 'Using Greedy Fit:     ', nlsf(1)%UseGreedyFit, term_blk
    
    allocate( Cr(1:num_obs_points, 1:num_obs_points), F(1:num_obs_points, 1:num_spat_fcns), r(1:num_obs_points))
    allocate( trndOBS(1:num_obs_points), resOBS(1:num_obs_points))
    allocate( distance_horiz(1:num_obs_points, 1:num_obs_points), distance_vert(1:num_obs_points, 1:num_obs_points))
    allocate( gamma(1:num_obs_points, 1:num_obs_points) )

    fmax = fmax * maxval(obs%f_psqm(1:num_obs_points))
    domain_average = Get_Domain_Average(obs, grid)

    if(IsLogT) then
        A = 1.D0 / tow_area_sqm ! 1 scallop per tow 
        SF=sum(obs%f_psqm(1:num_obs_points))/float(num_obs_points)
        SF=SF/5.D0  ! mean / 5 ~ median
        obs%f_psqm(1:num_obs_points)=log(( A+obs%f_psqm(1:num_obs_points) )/SF)
    endif
    
    if (nlsf(1)%UseGreedyFit.eq.1) call FitNLSFunctionsGreedy(obs, nlsf)
    if (nlsf(1)%UseGreedyFit.eq.0) call FitNLSFunctions(obs, nlsf, 0)
    do j=1, nsf
        write(*,*)nlsf(j)%d, ' ', nlsf(j)%form, nlsf(j)%x0, nlsf(j)%lambda
    enddo

    !-------------------------------------------------------------------------
    ! OLS fit with spatial functions
    !-------------------------------------------------------------------------
    Cr(1:num_obs_points, 1:num_obs_points)=0.D0
    do j=1, num_obs_points
        Cr(j, j)=1.D0
    enddo
    call Evaluate_Spatial_Function(obs, F, num_spat_fcns, num_obs_points, nlsf)
    call GLS(obs%f_psqm, F, Cr, num_obs_points, num_spat_fcns, beta, Cbeta, r)
    write(*,*)'OLSres:', sqrt(sum(r(1:num_obs_points)**2)/float(num_obs_points))

    !-------------------------------------------------------------------------
    ! Fit variogram parameters to OLS residual
    !-------------------------------------------------------------------------
    call Write_Vector_Scalar_Field(num_obs_points, r, 'OLSresidual.txt')
    call Write_Vector_Scalar_Field(num_obs_points, obs%f_psqm, 'data.txt')
    call Compute_Distance(obs, obs, distance_horiz, distance_vert, num_obs_points)

    call Compute_Empirical_Variogram(num_obs_points, distance_horiz, distance_vert, Gamma, num_obs_points, r, par)
    open(63, file='KRIGpar.txt')
    write(63,*)par%sill, par%nugget, par%alpha, par%Wz
    close(63)

    !-------------------------------------------------------------------------
    ! Compute Universal Kriging estimate of field on grid (fest) given
    ! observations x_obs, y_obs, z_obs, field_obs. Also returns the estimate of spatial function
    ! coeficients, beta, and posterior covariance of beta(Cbeta).
    !-------------------------------------------------------------------------
    call UK_GLS(grid, obs, num_spat_fcns, par, beta, Cbeta, eps, Ceps, nlsf)
    call Evaluate_Spatial_Function(obs, F, num_spat_fcns, num_obs_points, nlsf)
    atmp=1.D0
    btmp=0.D0
    call dgemv('N', num_obs_points, num_spat_fcns, atmp, F, num_obs_points, beta, 1, btmp, trndOBS, 1)
    resOBS(1:num_obs_points)=obs%f_psqm(1:num_obs_points)-trndOBS(1:num_obs_points)
    write(*,*)'GLSres:', sqrt(sum(resOBS(1:num_obs_points)**2)/float(num_obs_points))
else 
    ! simulate from user supplied prior estimate of beta, Cbeta, eps, Ceps
    call UK_prior(grid, num_spat_fcns, par, beta, Cbeta, eps, Ceps)
endif

call OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, A, domain_average, &
&                    IsLogT, IsMatchMean, IsHiLimit, domain_name, alpha)

write(*,*)'num_points, num_survey', num_points, num_obs_points
deallocate( distance_horiz, distance_vert, beta, Cbeta, Ceps, r)

stop
endprogram

!--------------------------------------------------------------------------------------------------
!> Purpose: Read parameter values, flags, etc. from an ascii text input file:"UK.inp".  Parameters etc. 
!> to be read from UK.inp are identified by tag before '='.  Values are read from the 
!> line to the right of an "=" character. Logical variables are read from 'T','F'.
!>
!> outputs: 
!>       all variables
!>
!--------------------------------------------------------------------------------------------------
! Keston Smith, Tom Callaghan (IBSS) 2024
!--------------------------------------------------------------------------------------------------
subroutine Read_Startup_Config(domain_name, SimType, obsfile, NRand, IsLogT, IsHiLimit, fmax, IsMatchMean, par, alpha)
use globals
use KrigMod
implicit none
character(2),intent(out):: domain_name
integer, intent(out) :: SimType
type(KrigPar), intent(out):: par
integer j, k, io
integer, intent(out):: NRand
character(72),intent(out):: obsfile

logical IsLogT,IsHiLimit,IsMatchMean
character(72) :: input_string
character(tag_len) tag
character(value_len) value
real(dp),intent(out)::  fmax,alpha
logical exists

! set default values for parameters not in file
IsLogT=.true.
IsHiLimit=.false.
!        IsClimEst=.false.
IsMatchMean=.true.
alpha=1.D0
SimType = 1

! Check if configuration file exists
input_string = 'Configuration/UK.inp'
inquire(file=input_string, exist=exists)

if (.NOT. exists) then
    PRINT *, term_red, input_string, ' NOT FOUND', term_blk
    stop
endif
open(69,file=input_string)
do
    input_string=""
    read(69,'(a)',iostat=io) input_string
    if (io.lt.0) exit

    if (input_string(1:1) .NE. '#') then
        j = scan(input_string,"=",back=.true.)
        tag = trim(adjustl(input_string(1:j-1)))
        ! explicitly ignore inline comment
        k = scan(input_string,"#",back=.true.)
        if (k .EQ. 0) k = len(input_string) + 1
        value =  trim(adjustl(input_string(j+1:k-1)))

        select case (tag)
        case('Domain Name')
            domain_name = value(1:2)
            if (.not. ( any ((/ domain_name.eq.'MA', domain_name.eq.'GB'/)) )) then
                write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', domain_name, term_blk
                stop
            endif

        case('Input File')
            obsfile = value
            inquire(file=obsfile, exist=exists)

            if (exists) then
                write(*,*)'Using observation file ',obsfile
            else
                PRINT *, term_red, obsfile, ' NOT FOUND', term_blk
                stop
            endif

        case('Log Transform')
            read(value,*) IsLogT

        case('High Limit Factor')
            read(value, *) fmax

        case('Power Transform Parameter')
            if (IsLogT) then
                ! Forcing alpha to 1.0
                alpha=1.D0
                write(*,*) term_yel, 'Log Transform is T, ignoring Power Transform Param', term_blk
            else
                read(value,*) alpha
                IsHiLimit = .true.
                write(*,*)'Is this the fmax you were searching for?', fmax
            endif

        case('Number of Random Fields')
            read( value,*) NRand

        case('Kriging variogram form')
            read(value,*) par%form

        case('Match stratified mean')
            read(value,*) IsMatchMean

        case('SimType')
            read(value,*) SimType

        case default
            write(*,*) term_yel, 'ReadInput: Unrecognized line in UK.inp'
            write(*,*) 'Unrecognized Line->',input_string
            write(*,*) 'This is probably not a problem', term_blk
            !stop
    end select
    endif
end do
close(69)
return
endsubroutine Read_Startup_Config
        
!---------------------------------------------------------------------------------------------------
!> Purpose: This subroutine writes files for output.  This includes a central prediction: 
!> "KrigingEstimate.txt" and random fields generated from the posterior distribution:
!> "RandomFieldN.txt", where N =1:Nrand. Predictor standard deviation  is output to "KrigSTD.txt".
!> Function coefficient 
!---------------------------------------------------------------------------------------------------
subroutine OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, A, domain_average, &
&                  IsLogT, IsMatchMean, IsHiLimit, domain_name, alpha)
use GridManagerMod
use NonLinearSpatialFcnMod
use KrigMod
implicit none

type(Grid_Data_Class), intent(inout) :: grid
type(NLSFPar), intent(in)::nlsf(*)
                                    
character(2) domain_name
integer, intent(in) :: num_points, num_spat_fcns, Nrand
real(dp), intent(in) :: eps(*), beta(*), Cbeta(num_spat_fcns,*), fmax, SF, A, domain_average, alpha
real(dp), intent(inout) :: Ceps(num_points,*)
logical, intent(in) ::IsLogT, IsMatchMean, IsHiLimit
integer j, k, n
real(dp) trend(num_points), V(num_points), Fg(num_points, num_spat_fcns), MuY, EnsMu, EnsSTD
real(dp) logf(num_points), adj, RandomField(num_points, Nrand)
character(72) buf

write(*,*)'output fmax, SF, A=', fmax, SF, A
do n=1, num_points
    V(n)=Ceps(n, n)
enddo
grid%f_psqm(1:num_points)=grid%f_psqm(1:num_points)**(1./alpha)

logf(1:num_points)=grid%f_psqm(1:num_points)
if(IsLogT) grid%f_psqm(1:num_points)=SF*exp( grid%f_psqm(1:num_points) + V(1:num_points)/2. ) - A  ! adjusted inverse log(A+f)
if(IsHiLimit)call limitz(num_points, grid%f_psqm, grid%z, fmax, domain_name)
MuY=sum( grid%f_psqm(1:num_points) )/float(num_points)
if(IsMatchMean)grid%f_psqm(1:num_points)=domain_average*grid%f_psqm(1:num_points)/MuY
if(IsHiLimit)call limitz(num_points, grid%f_psqm, grid%z, fmax, domain_name)
call Write_Vector_Scalar_Field(num_points, grid%f_psqm, 'KrigingEstimate.txt')

call Evaluate_Spatial_Function(grid, Fg, num_spat_fcns, num_points, nlsf)
trend(1:num_points)=matmul( Fg(1:num_points, 1:num_spat_fcns), beta(1:num_spat_fcns)) 

if(IsLogT)trend(1:num_points)=SF*exp(trend(1:num_points))-A
if(IsMatchMean)trend(1:num_points)=domain_average*trend(1:num_points)/MuY
call Write_Vector_Scalar_Field(num_points, trend, 'SpatialTrend.txt')

call Write_Vector_Scalar_Field(num_points, eps, 'epsilon.txt')
call Write_Vector_Scalar_Field(num_spat_fcns, beta, 'beta.txt')

call write_csv(num_spat_fcns, num_spat_fcns, Cbeta, 'CovBeta.csv', num_spat_fcns)

call Evaluate_Spatial_Function(grid, Fg, num_spat_fcns, num_points, nlsf)
Ceps(1:num_points, 1:num_points) = Ceps(1:num_points, 1:num_points)&
&    + matmul( Fg(1:num_points, 1:num_spat_fcns) , &
&              matmul(Cbeta(1:num_spat_fcns, 1:num_spat_fcns), transpose(Fg(1:num_points, 1:num_spat_fcns)) ) )
do n=1, num_points
 V(n)=Ceps(n, n)
enddo
if(IsLogT)call Write_Vector_Scalar_Field(num_points, SF*exp(sqrt(V(1:num_points)))-A, 'KrigSTD.txt')
if(.not.IsLogT)call Write_Vector_Scalar_Field(num_points, sqrt(V(1:num_points)), 'KrigSTD.txt')

if(IsLogT)call RandomSampleF(num_points, num_points, NRand, logf(1:n), Ceps, RandomField)
if(.not.IsLogT)call RandomSampleF(num_points, num_points, NRand, grid%f_psqm(1:n)**alpha, Ceps, RandomField)
RandomField(1:num_points, 1:Nrand)=RandomField(1:num_points, 1:Nrand)**(1./alpha)
do k=1, num_points
    if(IsLogT)adj=SF*exp(sqrt(V(k)))-A
    if(.not.IsLogT)adj=sqrt(V(k))
    EnsMu=sum(  RandomField(k, 1:Nrand) )/float(Nrand)
    EnsSTD=sqrt( sum( ( RandomField(k, 1:Nrand)-EnsMu )**2 )/float(Nrand) )
    if(EnsSTD.gt.0.)then
        RandomField(k, 1:Nrand) = grid%f_psqm(k) +( RandomField(k, 1:Nrand) - EnsMu )*adj/EnsSTD
    else
        RandomField(k, 1:Nrand) = grid%f_psqm(k) + RandomField(k, 1:Nrand) - EnsMu 
    endif
    if(IsHiLimit)call limitz(Nrand, RandomField(k, 1:NRand), grid%z(k)+0.*RandomField(k, 1:NRand), &
                            fmax, domain_name)
enddo

do j=1, Nrand
    write(buf, '(I6)')j
    call Write_Vector_Scalar_Field(num_points, RandomField(1:num_points, j), 'RandomField'//trim(adjustl(buf))//'.txt')
enddo

return
endsubroutine OutputUK
