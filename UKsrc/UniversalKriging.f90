!--------------------------------------------------------------------------------------------------
!> @mainpage Universal Kriging
!>
!> Purpose: This program is designed to simulate random fields under the assumptions of Universal 
!> Kriging (UK).  It is assumed that the underlying spatial field is a linear combination of known 
!> spatial functions and a stationary zero mean random field with known variogram parameters.  The 
!> program can be configured in two ways:
!>
!> (1) To simulate random fields conditioned on the assumed UK model and a set of observations.
!>     (postrior simulation).
!>
!> (0) To simulate random fields based on specified mean spatial coefficients, their covariance
!>     and known variogram with known parameters (prior simulation).
!>
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!> 
!> @section m1p1 Implementation of random recruitment
!> Spatial fields of recruitment are generated by the software located in directory "/UKsrc".  The output files, such as:
!> "RecruitField/RecruityyyyMA/RandomFieldxx.txt" contain @f$n_{nodes}@f$ vectors of independent random fields conditioned on 
!> survey observations from "Data/RecruitsyyyyMA.csv", where xx runs from @f$1@f$ to @f$Nrand@f$ and @f$yyyy@f$ 1979 to 2018.
!>
!> @subsection m1p1p1 Interpolation Algorithm
!> The interpolation of recruit data is carried out with a Universal Kriging (UK) algorithm allowing for sampling from the posterior distribution. 
!>
!> @subsubsection m1p1p1p1 Universal Kriging
!> Universal kriging (UK) is a generalization of ordinary kriging in which a set of spatial functions are used to model the
!> trend of a set of point observations.  The underlying model is:
!> @f[
!> f(x,y,H(x,y),\lambda)=\sum_{k=1}^{n_f} f_k(x,y,H(x,y),\lambda_k) +\epsilon(x,y) 
!> @f] 
!> where @f$f_k@f$ are the known spatial functions and @f$\epsilon(x,y)@f$ is a zero mean, spatially correlated,  stationary random 
!> process with semi-variogram @f$\gamma(s)@f$. For a summary of UK see Cressie 1993, pages 151 -180.\n
!> % The spatially variable @f$x@f$ here is taken to include latitude, longitude and, bathymetric depth(@f$x=[lat,lon,z(lat,lon)]@f$). 
!> 
!> @subsubsection m1p1p1p2 Spatial functions
!> The spatial functions (SF) used here are  a set of one dimensional, bounded, C-infinity functions with two parameters, 
!> 
!> Gaussian Bump:
!> @f[
!> f_a (s,\lambda,x_0) = \exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Logistic curve:
!> @f[
!> f_b (s,\lambda,x_0) = \frac{1}{1+\exp( -\frac{s-x_0}{\lambda} ) }
!> @f]
!> Sin Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \sin(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Cos Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \cos(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!>
!> In all of the function form @f$\lambda@f$ controls the width of the transition and @f$x_0@f$ the transition point. 
!> 
!> After fitting these to the bathymetric variable (H) we can introduce interaction. Allowing interaction terms for the 
!> spatial functions depending on bathymetry only we can define, @f$g_j(x,H,\lambda^j,{x_0}^j,\lambda_k,{x_0}^k)=f_j(x)f_k ( H )@f$
!> @f[
!> f(x,y,H)=\sum_i f_i(H,\lambda^i,z_0^i) + \sum_j f_{j_x}(x,\lambda^{j_x},x_0^{j_x}) f_k(z,\lambda^k,x_0^k)+ \sum_j f_{j_y}(y,\lambda^{j_y},x_0^{j_y}) f_k(z,\lambda^k,x_0^k)
!> @f]
!>
!> Here @f$z@f$ is bathymetric depth. We start by fitting nonlinear parameters @f$\lambda^{c,s}@f$ and @f$x_0^{c,s}@f$ to log 
!> recruitment for "cross shelf" structure.  
!> @f[
!> f(x,y,z)=\beta_0+\sum_i \beta_i f_i(z) + \sum_j \beta_j g_j(x,z)+\sum_k \beta_k g_k(y,z)+ \epsilon
!> @f]
!> where @f$\beta_i@f$ are coefficients for the spatial functions and @f$\epsilon@f$ is the zero mean noise process associated with UK.
!> 
!> @subsubsection m1p1p1p3 Fitting non-linear parameters
!> A brute force approach is taken to fitting the nonlinear parameters @f$x_0@f$ and @f$\lambda@f$.  A search range is 
!> determined based on the geographic range of the observations.  The parameters are then fit to minimize the misfit to 
!> observations. 
!>
!> Subroutine @a FitNLSFunc parameter np).  The nonlinear parameters are fit by minimizing RMS misfit to the simple least 
!> squares fit with a smoothness penalty,
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x= S(\lambda)@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are 
!> temporarily assigned (by least squares) constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ 
!> for all examples used here (see subroutine @a NLSFuncPen).  Other one dimensional function forms can be added to the 
!> software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!> A smoothness penalty is imposed for each function based on the analytic 
!> 
!> @subsection m1p1p2 Residual process
!> After performing an ordinary least squares fit for the SF coeficients, @f$\beta@f$, we have an estimate of @f$\epsilon@f$. 
!> An empirical variogram is computed subroutine @a variogramF, and variogram parameters are fit (again by brute force).  
!> The variogram forms allowed are "spherical", "exponential", and "gaussian".  The form is hard-coded in the main program, 
!> UniversalKriging.f90.
!>
!> @subsubsection m1p1p2p1 Posterior sampling
!> With the fitting of the residual we have a covariance for @f$\epsilon@f$ and the estimation problem becomes one of 
!> Generalized Least Squares (GLS).  Posterior sampling is then conducted  achieved posterior sampling is Treating the TBD
!>
!> @section m1p2 Non Linear Spatial function fitting for UK
!> The universal kriging algorithm described above is used to build a distribution based on the historical recruitment data 
!> (1979-present).  Spatial function forms of one variable were selected for smoothness and boundedness. We have:\n
!> Gaussian bump
!> 
!> The nonlinear parameters are fit by minimizing RMS misfit to the simple least squares fit. 
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are temporarily 
!> assigned constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ for all examples used here.  
!> Other one dimensional function forms can be added to the software in subroutine @a NLSFunc and @a NLSFFuncPen.
!> 
!-----------------------------------------------------------------------
program UKsimulation
use globals
use GridManagerMod
use LinearSpatialFcnMod
use NonLinearSpatialFcnMod
use KrigMod
USE RandomFieldMod
implicit none

real(dp)  atmp, btmp
real(dp), allocatable :: beta(:), Cbeta(:,:), eps(:), Ceps(:,:), Cr(:,:), F(:,:), r(:), trndOBS(:), resOBS(:)
real(dp), allocatable :: Dh(:,:), Dz(:,:), gamma(:,:), Veps(:), VSpFn(:), CbetaF(:,:), Fg(:,:)
real(dp), allocatable :: ClimEst(:), ClimEstObs(:), trend(:), Vtotal(:), logmu(:)
real(dp), allocatable :: RandomField(:,:)
integer   num_points, num_spat_fcns, num_obs_points, SimType, j, nits
real(dp)  fmax, A, DomainAverage, SF
! variables for nonlinear fitting
integer nsf, NRand, ncla
logical IsClimEst, IsHiLimit, IsMatchMean, IsLogT
character(72) obsfile, climfile
character(2) DomainName
type(Grid_Data_Class):: grid
type(Grid_Data_Class):: obs
type(KrigPar):: par
type(NLSFPar), allocatable ::nlsf(:)
real(dp) alpha
par%form='spherical'
IsLogT=.true.
IsHiLimit=.true.
IsClimEst=.false.
IsMatchMean=.true.
alpha=1.D0

write (*,*) term_grn, "PROGRAM STARTING", term_blk

call Read_Startup_Config(DomainName, SimType, obsfile, climfile, Nrand, IsLogT, IsHiLimit, fmax, IsMatchMean, IsClimEst, par, alpha)
!override UK.inp with command line arguments if present
ncla=command_argument_count()
if(ncla.ge.1)call get_command_argument(1, DomainName)
if(ncla.ge.2)call get_command_argument(2, obsfile)
if(ncla.ge.3)call get_command_argument(3, climfile)
if(ncla.ge.3)IsClimEst=.true.

write (*,*) term_blu,"Reading ", DomainName

write(*,*) 'Observation file:  ', trim(obsfile)
if(IsClimEst) write(*,*) 'Clim file:  ', trim(climfile)
write(*,*) 'Logtransorm', IsLogT
write(*,*) 'Match stratified sampling estimate', IsMatchMean
write(*,*) 'High limit fmax', fmax
write(*,*) 'Form of variagram: ', par%form
if (SimType .EQ. 0) write(*,*) 'SimType is priori simulation'
if (SimType .EQ. 1) write(*,*) 'SimType is posterior simulation'
write(*,*) term_blk

call random_seed( )

! Determine how many spatial functions are defined.
allocate(nlsf(1:1))
nsf = DefineNLSFunctions(nlsf, obs, .true.)
deallocate(nlsf)

allocate(nlsf(1:nsf))
nlsf(1:nsf)%nsf=nsf
num_spat_fcns = nsf+1

!
! Initalize grid point coordinates and bathymetry - initialize num_points
!
call Load_Grid(grid%x, grid%y, grid%z, grid%lat, grid%lon, grid%num_points, &
&              grid%E, grid%num_squares, grid%ManagementRegion, DomainName)
num_points=grid%num_points

allocate( beta(1:num_spat_fcns), Cbeta(1:num_spat_fcns, 1:num_spat_fcns), eps(1:num_points), Ceps(1:num_points, 1:num_points))
allocate( CbetaF(1:num_spat_fcns, 1:num_points))
allocate( Veps(1:num_points), VSpFn(1:num_points), Fg(1:num_points, 1:num_spat_fcns), trend(1:num_points))
allocate( Vtotal(1:num_points), logmu(1:num_points))
allocate( RandomField(1:num_points, 1:Nrand))
if (SimType.eq.1) then
    !
    ! Initalize data point coordinates, bathymetry and data - initialize no
    !
    call Load_Data(obs%x, obs%y, obs%z, obs%recr_psqm, obs%num_points, trim(obsfile))
    num_obs_points=obs%num_points

    obs%recr_psqm(1:num_obs_points)=obs%recr_psqm(1:num_obs_points)**alpha

    write(*,*)'num_obs_points=', num_obs_points, 'nsf limit=', nlsf(1)%nsflim, 'nsf=', nlsf(1)%nsf
    !-------------------------------------------------------------------------  
    ! nonlinear curve fitting for spatial functions
    !-------------------------------------------------------------------------  
    nsf = DefineNLSFunctions(nlsf, grid, .false.)
    
    write(*,'(A, A, A, I2, A, A)') term_blu, 'Using ', term_blk, nsf, term_blu, ' Spatial Functions'
    write(*,'(A,I2)') 'Using Truncate Range: ', nlsf(1)%IsTruncateRange
    write(*,'(A,I2)') 'Using Greedy Fit:     ', nlsf(1)%UseGreedyFit, term_blk
    
    allocate( Cr(1:num_obs_points, 1:num_obs_points), F(1:num_obs_points, 1:num_spat_fcns), r(1:num_obs_points))
    allocate( trndOBS(1:num_obs_points), resOBS(1:num_obs_points))
    allocate( Dh(1:num_obs_points, 1:num_obs_points), Dz(1:num_obs_points, 1:num_obs_points))
    allocate( gamma(1:num_obs_points, 1:num_obs_points) )

    fmax=fmax*maxval(obs%recr_psqm(1:num_obs_points))
    call Get_Domain_Average(obs, grid, DomainAverage)

    if(IsLogT) then
        A = 1.D0 / tow_area_sqm ! 1 scallop per tow 
        SF=sum(obs%recr_psqm(1:num_obs_points))/float(num_obs_points)
        SF=SF/5.D0  ! mean / 5 ~ median
        obs%recr_psqm(1:num_obs_points)=log(( A+obs%recr_psqm(1:num_obs_points) )/SF)
    endif
    
    if(IsClimEst)then
        allocate(ClimEst(1:num_points), ClimEstObs(1:num_obs_points))
        write(*,*)'ClimFile=', climfile
        call Read_CSV(climfile, ClimEst, j)
        ClimEst(1:num_points)=ClimEst(1:num_points)**alpha
        call Write_Vector_Scalar_Field(num_points, ClimEst(1:num_points), 'ClimEstField.txt')
        write(*,*)'climatology: read num_points=', j, 'values from ', trim(ClimFile)
        if (IsLogT)ClimEst(1:num_points)=log(A+ClimEst(1:num_points))
        call Interpret_From_Grid(grid, ClimEst, obs, ClimEstObs)
        call Write_Vector_Scalar_Field(num_obs_points, ClimEstObs(1:num_obs_points), 'ClimEstObs.txt')
        call Write_Vector_Scalar_Field(num_obs_points, obs%recr_psqm(1:num_obs_points), 'RawObs.txt')
        obs%recr_psqm(1:num_obs_points)=obs%recr_psqm(1:num_obs_points)-ClimEstObs(1:num_obs_points)
        call Write_Vector_Scalar_Field(num_obs_points, obs%recr_psqm(1:num_obs_points), 'AdjObs.txt')
    endif

    if (nlsf(1)%UseGreedyFit.eq.1) call FitNLSFunctionsGreedy(obs, nlsf)
    if (nlsf(1)%UseGreedyFit.eq.0) call FitNLSFunctions(obs, nlsf, 0)
    nsf=nlsf(1)%nsf
    do j=1, nlsf(1)%nsf
        write(*,*)nlsf(j)%d, ' ', nlsf(j)%form, nlsf(j)%x0, nlsf(j)%lambda
    enddo

    !-------------------------------------------------------------------------
    ! OLS fit with spatial functions
    !-------------------------------------------------------------------------
    Cr(1:num_obs_points, 1:num_obs_points)=0.D0
    do j=1, num_obs_points
        Cr(j, j)=1.D0
    enddo
    call spatial_function(obs, F, num_spat_fcns, num_obs_points, nlsf)
    call GLS(obs%recr_psqm, F, Cr, num_obs_points, num_spat_fcns, beta, Cbeta, r)
    write(*,*)'OLSres:', sqrt(sum(r(1:num_obs_points)**2)/float(num_obs_points))

    !-------------------------------------------------------------------------
    ! Fit variogram parameters to OLS residual
    !-------------------------------------------------------------------------
    call Write_Vector_Scalar_Field(num_obs_points, r, 'OLSresidual.txt')
    call Write_Vector_Scalar_Field(num_obs_points, obs%recr_psqm, 'data.txt')
    call distance(obs, obs, Dh, Dz, num_obs_points)
    nits=1
    do j=1, nits
        call variogramF(num_obs_points, Dh, Dz, Gamma, num_obs_points, r, par)
        open(63, file='KRIGpar.txt')
        write(63,*)par%c, par%c0, par%alpha, par%Wz
        close(63)

        !-------------------------------------------------------------------------
        ! Compute Universal Kriging estimate of field on grid (fest) given
        ! observations xo, yo, zo, fo. Also returns the estimate of spatial function
        ! coeficients, beta, and posterior covariance of beta(Cbeta).
        !-------------------------------------------------------------------------
        call UK_GLS(grid, obs, num_spat_fcns, par, beta, Cbeta, eps, Ceps, nlsf)
        call spatial_function(obs, F, num_spat_fcns, num_obs_points, nlsf)
        atmp=1.D0
        btmp=0.D0
        call dgemv('N', num_obs_points, num_spat_fcns, atmp, F, num_obs_points, beta, 1, btmp, trndOBS, 1)
        resOBS(1:num_obs_points)=obs%recr_psqm(1:num_obs_points)-trndOBS(1:num_obs_points)
        write(*,*)'GLSres:', sqrt(sum(resOBS(1:num_obs_points)**2)/float(num_obs_points))
    enddo
else 
    ! simulate from user supplied prior estimate of beta, Cbeta, eps, Ceps
    call UK_prior(grid, num_spat_fcns, par, beta, Cbeta, eps, Ceps)
endif

call OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, ClimEst, fmax, SF, A, DomainAverage, &
&                    IsLogT, IsClimEst, IsMatchMean, IsHiLimit, DomainName, alpha)

call Interpret_From_Grid(grid, grid%recr_psqm, obs, r)
r(1:num_obs_points)=r(1:num_obs_points)**(1./alpha)
call Write_Vector_Scalar_Field(num_obs_points, r, 'KrigAtObs.txt')

deallocate( Dh, Dz, beta, Cbeta, Ceps, r)

stop
endprogram

!--------------------------------------------------------------------------------------------------
!> Purpose: Read parameter values, flags, etc. from a ascii text input file:"UK.inp".  Parameters etc. 
!> to be read from UK.inp are identified by the first letter of the line.  Values are read from the 
!> line to the right of an "=" character. Logical variables are read from 'T','F'.
!>
!> outputs: 
!>       all variables
!>
!--------------------------------------------------------------------------------------------------
! Keston Smith, Tom Callaghan (IBSS) 2024
!--------------------------------------------------------------------------------------------------
subroutine Read_Startup_Config(DomainName, SimType, obsfile, climfile, NRand, IsLogT, IsHiLimit, fmax,&
    &       IsMatchMean, IsClimEst, par, alpha)
        use globals
        use KrigMod
        implicit none
        character(2),intent(out):: DomainName
        integer, intent(out) :: SimType
        type(KrigPar), intent(out):: par
        integer j, k, io
        integer, intent(out):: NRand
        character(72),intent(out):: obsfile,climfile
        
        logical IsLogT,IsHiLimit,IsMatchMean,IsClimEst
        character(72) :: input_string
        character(tag_len) tag
        character(value_len) value
        real(dp),intent(out)::  fmax,alpha
        logical exists
        
        IsClimEst=.false.
        IsHiLimit=.false.
        IsLogT = .false.
        open(69,file='UK.inp')
        do
            input_string=""
            read(69,'(a)',iostat=io) input_string
            if (io.lt.0) exit
        
            if (input_string(1:1) .NE. '#') then
                j = scan(input_string,"=",back=.true.)
                tag = trim(adjustl(input_string(1:j-1)))
                ! explicitly ignore inline comment
                k = scan(input_string,"#",back=.true.)
                if (k .EQ. 0) k = len(input_string) + 1
                value =  trim(adjustl(input_string(j+1:k-1)))
    
                select case (tag)
                case('Domain Name')
                    DomainName = value(1:2)
                    if (.not. ( any ((/ DomainName.eq.'MA', DomainName.eq.'GB'/)) )) then
                        write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', DomainName, term_blk
                        stop
                    endif
    
                case('Input File')
                    obsfile = value
                    inquire(file=obsfile, exist=exists)
        
                    if (exists) then
                        write(*,*)'Using observation file ',obsfile
                    else
                        PRINT *, term_red, obsfile, ' NOT FOUND', term_blk
                        stop
                    endif
    
                case('Log Transform')
                    read(value,*) IsLogT
    
                case('High Limit Factor')
                    read(value, *) fmax
    
                case('Power Transform Parameter')
                    if (IsLogT) then
                        ! Forcing alpha to 1.0
                        alpha=1.D0
                        write(*,*) term_yel, 'Log Transform is T, ignoring Power Transform Param', term_blk
                    else
                        read(value,*) alpha
                        IsHiLimit = .true.
                        write(*,*)'Is this the fmax you were searching for?', fmax
                    endif
    
                case('Climatology')
                    climfile = value
                    inquire(file=climfile, exist=exists)
        
                    if (exists) then
                        write(*,*)'taking climatological background field from ',climfile
                    else
                        PRINT *, term_red, climfile, ' NOT FOUND', term_blk
                        stop
                    endif
                        
                    IsClimEst=.true.
    
                case('Number of Random Fields')
                    read( value,*) NRand
    
                case('Kriging variogram form')
                    read(value,*) par%form
    
                case('Match stratified mean')
                    read(value,*) IsMatchMean
                    !Match stratified mean = F
    
                case('SimType')
                    read(value,*) SimType
        
                case default
                    write(*,*) term_yel, 'ReadInput: Unrecognized line in UK.inp'
                    write(*,*) 'Unrecognized Line->',input_string
                    write(*,*) 'This is probably not a problem', term_blk
                    !stop
            end select
            endif
        end do
        close(69)
        return
        end
        
    !---------------------------------------------------------------------------------------------------
!> Purpose: This subroutine writes files for output.  This includes a central prediction: 
!> "KrigingEstimate.txt" and random fields generated from the posterior distribution:
!> "RandomFieldN.txt", where N =1:Nrand. Predictor standard deviation  is output to "KrigSTD.txt".
!> Function coefficient 
!---------------------------------------------------------------------------------------------------
subroutine OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, ClimEst, fmax, SF, A, DomainAverage, &
    IsLogT, IsClimEst, IsMatchMean, IsHiLimit, DomainName, alpha)
use GridManagerMod
use NonLinearSpatialFcnMod
use KrigMod
implicit none

type(Grid_Data_Class), intent(inout) :: grid
type(NLSFPar), intent(in)::nlsf(*)
                                    
character(2) DomainName
integer, intent(in) :: num_points, num_spat_fcns, Nrand
real(dp), intent(in) :: eps(*), beta(*), Cbeta(num_spat_fcns,*), ClimEst(*), fmax, SF, A, DomainAverage, alpha
real(dp), intent(inout) :: Ceps(num_points,*)
logical, intent(in) ::IsLogT, IsClimEst, IsMatchMean, IsHiLimit
integer j, k, n
real(dp) trend(num_points), V(num_points), Fg(num_points, num_spat_fcns), MuY, EnsMu, EnsSTD
real(dp) logf(num_points), adj, RandomField(num_points, Nrand)
character(72) buf

write(*,*)'output fmax, SF, A=', fmax, SF, A
do n=1, num_points
    V(n)=Ceps(n, n)
enddo
grid%recr_psqm(1:num_points)=grid%recr_psqm(1:num_points)**(1./alpha)
if(IsClimEst)grid%recr_psqm(1:num_points)=grid%recr_psqm(1:num_points)+ClimEst(1:num_points)**(1./alpha)
logf(1:num_points)=grid%recr_psqm(1:num_points)
if(IsLogT) grid%recr_psqm(1:num_points)=SF*exp( grid%recr_psqm(1:num_points) + V(1:num_points)/2. ) - A  ! adjusted inverse log(A+f)
if(IsHiLimit)call limitz(num_points, grid%recr_psqm, grid%z, fmax, DomainName)
MuY=sum( grid%recr_psqm(1:num_points) )/float(num_points)
if(IsMatchMean)grid%recr_psqm(1:num_points)=DomainAverage*grid%recr_psqm(1:num_points)/MuY
if(IsHiLimit)call limitz(num_points, grid%recr_psqm, grid%z, fmax, DomainName)
call Write_Vector_Scalar_Field(num_points, grid%recr_psqm, 'KrigingEstimate.txt')

call spatial_function(grid, Fg, num_spat_fcns, num_points, nlsf)
trend(1:num_points)=matmul( Fg(1:num_points, 1:num_spat_fcns), beta(1:num_spat_fcns)) 
if(IsClimEst)trend(1:num_points)=trend(1:num_points)+ClimEst(1:num_points)
if(IsLogT)trend(1:num_points)=SF*exp(trend(1:num_points))-A
if(IsMatchMean)trend(1:num_points)=DomainAverage*trend(1:num_points)/MuY
call Write_Vector_Scalar_Field(num_points, trend, 'SpatialTrend.txt')

call Write_Vector_Scalar_Field(num_points, eps, 'epsilon.txt')
call Write_Vector_Scalar_Field(num_spat_fcns, beta, 'beta.txt')

call write_csv(num_spat_fcns, num_spat_fcns, Cbeta, 'CovBeta.csv', num_spat_fcns)

call spatial_function(grid, Fg, num_spat_fcns, num_points, nlsf)
Ceps(1:num_points, 1:num_points) = Ceps(1:num_points, 1:num_points)&
&    + matmul( Fg(1:num_points, 1:num_spat_fcns) , &
&              matmul(Cbeta(1:num_spat_fcns, 1:num_spat_fcns), transpose(Fg(1:num_points, 1:num_spat_fcns)) ) )
do n=1, num_points
 V(n)=Ceps(n, n)
enddo
if(IsLogT)call Write_Vector_Scalar_Field(num_points, SF*exp(sqrt(V(1:num_points)))-A, 'KrigSTD.txt')
if(.not.IsLogT)call Write_Vector_Scalar_Field(num_points, sqrt(V(1:num_points)), 'KrigSTD.txt')

if(IsLogT)call RandomSampleF(num_points, num_points, NRand, logf(1:n), Ceps, RandomField)
if(.not.IsLogT)call RandomSampleF(num_points, num_points, NRand, grid%recr_psqm(1:n)**alpha, Ceps, RandomField)
RandomField(1:num_points, 1:Nrand)=RandomField(1:num_points, 1:Nrand)**(1./alpha)
do k=1, num_points
    if(IsLogT)adj=SF*exp(sqrt(V(k)))-A
    if(.not.IsLogT)adj=sqrt(V(k))
    EnsMu=sum(  RandomField(k, 1:Nrand) )/float(Nrand)
    EnsSTD=sqrt( sum( ( RandomField(k, 1:Nrand)-EnsMu )**2 )/float(Nrand) )
    if(EnsSTD.gt.0.)then
        RandomField(k, 1:Nrand) = grid%recr_psqm(k) +( RandomField(k, 1:Nrand) - EnsMu )*adj/EnsSTD
    else
        RandomField(k, 1:Nrand) = grid%recr_psqm(k) + RandomField(k, 1:Nrand) - EnsMu 
    endif
    if(IsHiLimit)call limitz(Nrand, RandomField(k, 1:NRand), grid%z(k)+0.*RandomField(k, 1:NRand), &
                            fmax, DomainName)
enddo

do j=1, Nrand
    write(buf, '(I6)')j
    call Write_Vector_Scalar_Field(num_points, RandomField(1:num_points, j), 'RandomField'//trim(adjustl(buf))//'.txt')
enddo

return
end
