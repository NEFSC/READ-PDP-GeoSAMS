!--------------------------------------------------------------------------------------------------
!> @mainpage Universal Kriging
!>
!> Purpose: This program is designed to simulate random fields under the assumptions of Universal 
!> Kriging (UK).  It is assumed that the underlying spatial field is a linear combination of known 
!> spatial functions and a stationary zero mean random field with known variogram parameters.  The 
!> program can be configured in two ways:
!>
!> (1) To simulate random fields conditioned on the assumed UK model and a set of observations.
!>     (postrior simulation).
!>
!> (0) To simulate random fields based on specified mean spatial coefficients, their covariance
!>     and known variogram with known parameters (prior simulation).
!>
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!> 
!> @section m1p1 Implementation of random recruitment
!> Spatial fields of recruitment are generated by the software located in directory "/UKsrc".  The output files, such as:
!> "RecruitField/RecruityyyyMA/RandomFieldxx.txt" contain @f$n_{nodes}@f$ vectors of independent random fields conditioned on 
!> survey observations from "Data/RecruitsyyyyMA.csv", where xx runs from @f$1@f$ to @f$Nrand@f$ and @f$yyyy@f$ 1979 to 2018.
!>
!> @subsection m1p1p1 Interpolation Algorithm
!> The interpolation of recruit data is carried out with a Universal Kriging (UK) algorithm allowing for sampling from the posterior distribution. 
!>
!> @subsubsection m1p1p1p1 Universal Kriging
!> Universal kriging (UK) is a generalization of ordinary kriging in which a set of spatial functions are used to model the
!> trend of a set of point observations.  The underlying model is:
!> @f[
!> f(x,y,H(x,y),\lambda)=\sum_{k=1}^{n_f} f_k(x,y,H(x,y),\lambda_k) +\epsilon(x,y) 
!> @f] 
!> where @f$f_k@f$ are the known spatial functions and @f$\epsilon(x,y)@f$ is a zero mean, spatially correlated,  stationary random 
!> process with semi-variogram @f$\gamma(s)@f$. For a summary of UK see Cressie 1993, pages 151 -180.\n
!> % The spatially variable @f$x@f$ here is taken to include latitude, longitude and, bathymetric depth(@f$x=[lat,lon,z(lat,lon)]@f$). 
!> 
!> @subsubsection m1p1p1p2 Spatial functions
!> The spatial functions (SF) used here are  a set of one dimensional, bounded, C-infinity functions with two parameters, 
!> 
!> Gaussian Bump:
!> @f[
!> f_a (s,\lambda,x_0) = \exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Logistic curve:
!> @f[
!> f_b (s,\lambda,x_0) = \frac{1}{1+\exp( -\frac{s-x_0}{\lambda} ) }
!> @f]
!> Sin Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \sin(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!> Cos Exp curve:
!> @f[
!> f_c (s,\lambda,x_0) = \cos(\frac{s-x_0}{\lambda})\exp( - \left(\frac{s-x_0}{\lambda}\right)^2 )
!> @f]
!>
!> In all of the function form @f$\lambda@f$ controls the width of the transition and @f$x_0@f$ the transition point. 
!> 
!> After fitting these to the bathymetric variable (H) we can introduce interaction. Allowing interaction terms for the 
!> spatial functions depending on bathymetry only we can define, @f$g_j(x,H,\lambda^j,{x_0}^j,\lambda_k,{x_0}^k)=f_j(x)f_k ( H )@f$
!> @f[
!> f(x,y,H)=\sum_i f_i(H,\lambda^i,z_0^i) + \sum_j f_{j_x}(x,\lambda^{j_x},x_0^{j_x}) f_k(z,\lambda^k,x_0^k)+ \sum_j f_{j_y}(y,\lambda^{j_y},x_0^{j_y}) f_k(z,\lambda^k,x_0^k)
!> @f]
!>
!> Here @f$z@f$ is bathymetric depth. We start by fitting nonlinear parameters @f$\lambda^{c,s}@f$ and @f$x_0^{c,s}@f$ to log 
!> recruitment for "cross shelf" structure.  
!> @f[
!> f(x,y,z)=\beta_0+\sum_i \beta_i f_i(z) + \sum_j \beta_j g_j(x,z)+\sum_k \beta_k g_k(y,z)+ \epsilon
!> @f]
!> where @f$\beta_i@f$ are coefficients for the spatial functions and @f$\epsilon@f$ is the zero mean noise process associated with UK.
!> 
!> @subsubsection m1p1p1p3 Fitting non-linear parameters
!> A brute force approach is taken to fitting the nonlinear parameters @f$x_0@f$ and @f$\lambda@f$.  A search range is 
!> determined based on the geographic range of the observations.  The parameters are then fit to minimize the misfit to 
!> observations. 
!>
!> Subroutine @a NLSF_Fit_Function parameter np).  The nonlinear parameters are fit by minimizing RMS misfit to the simple least 
!> squares fit with a smoothness penalty,
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x= S(\lambda)@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are 
!> temporarily assigned (by least squares) constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ 
!> for all examples used here (see subroutine @a NLSF_Smooth_Penalty).  Other one dimensional function forms can be added to the 
!> software in subroutine @a NLSF_Evaluate_Fcn and @a NLSFFuncPen.
!> 
!> A smoothness penalty is imposed for each function based on the analytic 
!> 
!> @subsection m1p1p2 Residual process
!> After performing an ordinary least squares fit for the SF coeficients, @f$\beta@f$, we have an estimate of @f$\epsilon@f$. 
!> An empirical variogram is computed subroutine @a Krig_Comp_Emp_Variogram, and variogram parameters are fit (again by brute force).  
!> The variogram forms allowed are "spherical", "exponential", and "gaussian".  The form is hard-coded in the main program, 
!> UniversalKriging.f90.
!>
!> @subsubsection m1p1p2p1 Posterior sampling
!> With the fitting of the residual we have a covariance for @f$\epsilon@f$ and the estimation problem becomes one of 
!> Generalized Least Squares (LSF_Generalized_Least_Squares).  Posterior sampling is then conducted  achieved posterior sampling is Treating the TBD
!>
!> @section m1p2 Non Linear Spatial function fitting for UK
!> The universal kriging algorithm described above is used to build a distribution based on the historical recruitment data 
!> (1979-present).  Spatial function forms of one variable were selected for smoothness and boundedness. We have:\n
!> Gaussian bump
!> 
!> The nonlinear parameters are fit by minimizing RMS misfit to the simple least squares fit. 
!> @f[
!> J(x_0,\lambda)=\sqrt{ \frac{1}{n} \sum_i (d_i-a - b f(x_i|\lambda,x_0))^2 }+S(\lambda,x_0)
!> @f]
!> Where @f$S(\lambda,x_0)=\int_{-\infty}^\infty f''(x) ^2 d x@f$ is a roughness penalty, @f$a@f$ and @f$b@f$ are temporarily 
!> assigned constants fit to minimize @f$J@f$.  @f$S@f$ is proportional to @f$\lambda^{-3}@f$ for all examples used here.  
!> Other one dimensional function forms can be added to the software in subroutine @a NLSF_Evaluate_Fcn and @a NLSFFuncPen.
!> 
!-----------------------------------------------------------------------
program UKsimulation
use globals
use GridManagerMod
use LSF_Mod
use NLSF_Mod
use Krig_Mod
USE RandomFieldMod
implicit none

real(dp)  atmp, btmp
real(dp), allocatable :: beta(:), Cbeta(:,:), eps(:), Ceps(:,:), Cr(:,:), F(:,:), r(:), trndOBS(:), resOBS(:)
real(dp), allocatable :: distance_horiz(:,:), distance_vert(:,:)
real(dp), allocatable :: RandomField(:,:)
integer num_points, num_spat_fcns, num_obs_points, j
logical use_posterior_sim ! # F priori simulation, T posterior simulation
real(dp)  fmax, SF
! variables for nonlinear fitting
integer nsf, NRand, ncla
logical IsHiLimit, IsLogT!, IsMatchMean
character(fname_len) cfg_file_name
character(fname_len) obsfile, cmd
character(domain_len) domain_name
logical exists
type(Grid_Data_Class):: grid
type(Grid_Data_Class):: obs
type(Krig_Class):: par
type(NLSF_Class), allocatable ::nlsf(:)
real(dp) alpha
logical save_data

par%form='spherical'

write (*,*) term_grn, "PROGRAM STARTING", term_blk

ncla=command_argument_count()
if (ncla .eq. 0) then
    write(*,*) term_red, 'No UK configuration file given', term_blk
    call get_command(cmd)
    write(*,*) term_blu,'Typical use: $ ', term_yel, trim(cmd), ' UK.cfg', term_blk
    stop 1
endif

if(ncla.ge.1) call get_command_argument(1, cfg_file_name)
cfg_file_name = config_dir//trim(cfg_file_name)
inquire(file=cfg_file_name, exist=exists)
if (exists) then
    PRINT *, term_blu, trim(cfg_file_name), ' FOUND', term_blk
else
    PRINT *, term_red, trim(cfg_file_name), ' NOT FOUND', term_blk
    stop 1
endif

call Read_Startup_Config(cfg_file_name, domain_name, use_posterior_sim, Nrand, IsLogT, IsHiLimit, fmax, par, alpha, save_data)
!override UK.cfg with command line arguments if present. Used by python scripts
if(ncla.ge.2) then 
    call get_command_argument(2, domain_name)
    if (.not. ( any ((/ domain_name.eq.'MA', domain_name.eq.'GB'/)) )) then
        write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', domain_name, term_blk
        stop 1
    endif
    ! Force Grid file name
    cmd = domain_name//'xyzLatLon.csv'
    Call Set_Grid_Data_File_Name(cmd)
endif

if(ncla.ge.3) then
    call get_command_argument(3, obsfile)
    call Set_Obs_Data_File_Name(obsfile)
endif

if (ncla .ge. 4) then
    if (ncla .eq. 4) then
        call get_command_argument(4, cmd)
        save_data = (trim(cmd) .eq. 'T')
    else
        call get_command_argument(4, obsfile)
        call Set_Grid_Data_File_Name(obsfile)

        call get_command_argument(5, cmd)
        save_data = (trim(cmd) .eq. 'T')
    endif
endif

write (*,*) term_blu,"Reading ", domain_name

write(*,*) 'Observation file:  ', trim(Get_Obs_Data_File_Name())
write(*,*) 'Logtransorm', IsLogT
!write(*,*) 'Match stratified sampling estimate', IsMatchMean ! DEPRECATE
write(*,*) 'High limit fmax', fmax
write(*,*) 'Form of variagram: ', par%form
if (use_posterior_sim) then
    write(*,*) 'use_posterior_sim is posterior simulation'
else
    write(*,*) 'use_posterior_sim is priori simulation'
endif
if (save_data) then
    write(*,*) 'All data is saved'
else
    write(*,*) 'Only resulting estimate is saved'
endif
write(*,*) term_blk

call random_seed( )

! Determine how many spatial functions are defined.
allocate(nlsf(1:1))
nsf = NLSF_Define_Functions(nlsf, obs, .true.)
deallocate(nlsf)

num_spat_fcns = nsf + 1
allocate( beta(1:num_spat_fcns), Cbeta(1:num_spat_fcns, 1:num_spat_fcns) )
allocate(nlsf(1:nsf))

!
! Initalize grid point coordinates and bathymetry - initialize num_points
!
num_points = Load_Grid(grid%x, grid%y, grid%z, grid%lat, grid%lon)!, grid%ManagementRegion) Deprecate
grid%num_points = num_points

allocate( eps(1:num_points), Ceps(1:num_points, 1:num_points))
allocate( RandomField(1:num_points, 1:Nrand))

if (use_posterior_sim) then
    !
    ! Initalize data point coordinates, bathymetry and data - initialize no
    !
    obs%num_points = Load_Observation_Data(obs%x, obs%y, obs%z, obs%field_psqm)
    num_obs_points=obs%num_points
    obs%field_psqm(1:num_obs_points)=obs%field_psqm(1:num_obs_points)**alpha

    !-------------------------------------------------------------------------  
    ! nonlinear curve fitting for spatial functions
    !-------------------------------------------------------------------------  
    nsf = NLSF_Define_Functions(nlsf, grid, .false.)
    !nlsf(1:nsf)%nsflim = nsf

    write(*,*)'num_obs_points=', num_obs_points, 'nsf limit=', Get_NSF_Limit(), ' alpha = ', alpha
    write(*,*)'num_grid_points=', num_points
    write(*,'(A, A, A, I2, A, A)') term_blu, 'Using ', term_blk, nsf, term_blu, ' Spatial Functions'
    write(*,'(A,L2)') 'Is Truncate Range: ', Get_Is_Truncate_Range()
    write(*,'(A,L2)') 'Using Greedy Fit:  ', Get_Use_Greedy_Fit(), term_blk

    allocate( Cr(1:num_obs_points, 1:num_obs_points), F(1:num_obs_points, 1:num_spat_fcns), r(1:num_obs_points))
    allocate( trndOBS(1:num_obs_points), resOBS(1:num_obs_points))
    allocate( distance_horiz(1:num_obs_points, 1:num_obs_points), distance_vert(1:num_obs_points, 1:num_obs_points))
        
    fmax = fmax * maxval(obs%field_psqm(1:num_obs_points))
    !domain_average = Get_Domain_Average(obs, grid)

    if(IsLogT) then
        SF = sum(obs%field_psqm(1:num_obs_points))/float(num_obs_points)
        SF = SF/5.D0  ! mean / 5 ~ median
        obs%field_psqm(1:num_obs_points) = log((one_scallop_per_tow + obs%field_psqm(1:num_obs_points)) / SF)
    endif

    call NLSF_Select_Fit(obs, nlsf, save_data)
    do j=1, nsf
        write(*,*)nlsf(j)%axis, ' ', nlsf(j)%form, nlsf(j)%f0, nlsf(j)%lambda
    enddo

    !-------------------------------------------------------------------------
    ! OLS fit with spatial functions
    !-------------------------------------------------------------------------
    Cr(1:num_obs_points, 1:num_obs_points)=0.D0
    do j=1, num_obs_points
        Cr(j, j)=1.D0
    enddo
    F = Krig_Eval_Spatial_Function(obs, num_spat_fcns, num_obs_points, nlsf, save_data)
    r = LSF_Generalized_Least_Squares(obs%field_psqm, F, Cr, num_obs_points, num_spat_fcns, save_data)
    write(*,*)'OrdinaryLeastSqResidual:', sqrt(sum(r(1:num_obs_points)**2)/float(num_obs_points))

    !-------------------------------------------------------------------------
    ! Fit variogram parameters to OLS residual
    !-------------------------------------------------------------------------
    if (save_data) then
        call Write_Vector_Scalar_Field(num_obs_points, r, 'OLSresidual.txt')
        call Write_Vector_Scalar_Field(num_obs_points, obs%field_psqm, 'data.txt')
    endif
    call Krig_Compute_Distance(obs, obs, distance_horiz, distance_vert, num_obs_points)

    call Krig_Comp_Emp_Variogram(num_obs_points, distance_horiz, distance_vert, num_obs_points, r, par, save_data)

    if (save_data) then
        open(63, file='KRIGpar.txt')
        write(63,*)par%sill, par%nugget, par%alpha, par%Wz
        close(63)
    endif

    !-------------------------------------------------------------------------
    ! Compute Universal Kriging estimate of field on grid (fest) given
    ! observations x_obs, y_obs, z_obs, field_obs. Also returns the estimate of spatial function
    ! coeficients, beta, and posterior covariance of beta(Cbeta).
    !-------------------------------------------------------------------------
    call Krig_Generalized_Least_Sq(grid, obs, num_spat_fcns, par, beta, Cbeta, eps, Ceps, nlsf, save_data)
    F = Krig_Eval_Spatial_Function(obs, num_spat_fcns, num_obs_points, nlsf, save_data)
    atmp=1.D0
    btmp=0.D0
    call dgemv('N', num_obs_points, num_spat_fcns, atmp, F, num_obs_points, beta, 1, btmp, trndOBS, 1)
    resOBS(1:num_obs_points) = obs%field_psqm(1:num_obs_points) - trndOBS(1:num_obs_points)
    write(*,*)'GLSres:', sqrt(sum(resOBS(1:num_obs_points)**2) / float(num_obs_points))

else 
    ! simulate from user supplied prior estimate of beta, Cbeta, eps, Ceps
    call Krig_User_Estimates(grid, num_spat_fcns, par, beta, Cbeta, eps, Ceps)
endif  ! if use_posterior_sim

if (save_data) then
    call OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, &
    &                    IsLogT, IsHiLimit, domain_name, alpha)
else
    call OutputEstimates(num_points, num_spat_fcns, grid, Ceps, IsLogT, IsHiLimit, fmax, SF, domain_name, nlsf, beta)
endif

write(*,*)'num_points, num_survey', num_points, num_obs_points

deallocate( beta, Cbeta, nlsf)
deallocate( eps, Ceps)
deallocate( RandomField)

if (use_posterior_sim) then
    deallocate( Cr, F, r)
    deallocate( trndOBS, resOBS)
    deallocate( distance_horiz, distance_vert)
endif

stop 0
endprogram

!--------------------------------------------------------------------------------------------------
!> Purpose: Read parameter values, flags, etc. from an ascii text input file:"UK.cfg".  Parameters etc. 
!> to be read from UK.cfg are identified by tag before '='.  Values are read from the 
!> line to the right of an "=" character. Logical variables are read from 'T','F'.
!>
!> outputs: 
!>       all variables
!>
!--------------------------------------------------------------------------------------------------
! Keston Smith, Tom Callaghan (IBSS) 2024
!--------------------------------------------------------------------------------------------------
subroutine Read_Startup_Config(cfg_file_name,domain_name,use_posterior_sim,NRand,IsLogT,IsHiLimit,fmax,par,alpha,save_data)
use globals
use Krig_Mod
use NLSF_Mod, only : NLS_Set_Config_File_Name => Set_Config_File_Name
implicit none
character(*), intent(in) :: cfg_file_name
character(2),intent(out):: domain_name
logical, intent(out) :: use_posterior_sim
type(Krig_Class), intent(out):: par
integer j, k, io
integer, intent(out):: NRand

logical IsLogT,IsHiLimit! ,IsMatchMean
character(72) :: input_string
character(tag_len) tag
character(value_len) value
real(dp),intent(out)::  fmax,alpha
logical, intent(out) :: save_data

! set default values for parameters not in file
IsLogT=.true.
IsHiLimit=.false.
!IsMatchMean=.true.
alpha=1.D0
use_posterior_sim = .true.

open(69,file=cfg_file_name)
do
    input_string=""
    read(69,'(a)',iostat=io) input_string
    if (io.lt.0) exit

    if (input_string(1:1) .NE. '#') then
        j = scan(input_string,"=",back=.true.)
        tag = trim(adjustl(input_string(1:j-1)))
        ! explicitly ignore inline comment
        k = scan(input_string,"#",back=.true.)
        if (k .EQ. 0) k = len(input_string) + 1
        value =  trim(adjustl(input_string(j+1:k-1)))

        select case (tag)
        case('Domain Name')
            domain_name = value(1:2)
            if (.not. ( any ((/ domain_name.eq.'MA', domain_name.eq.'GB'/)) )) then
                write(*,*) term_red, ' **** INVALID DOMAIN NAME: ', domain_name, term_blk
                stop 1
            endif
            ! Force Grid file name
            value = domain_name//'xyzLatLon.csv'
            Call Set_Grid_Data_File_Name(value)

        case('Observation File')
            Call Set_Obs_Data_File_Name(value)

        case('Log Transform')
            read(value,*) IsLogT

        case('High Limit Factor')
            read(value, *) fmax

        case('Power Transform Parameter')
            if (IsLogT) then
                ! Forcing alpha to 1.0
                alpha=1.D0
                write(*,*) term_yel, 'Log Transform is T, ignoring Power Transform Param', term_blk
            else
                read(value,*) alpha
                IsHiLimit = .true.
                write(*,*)'Is this the fmax you were searching for?', fmax
            endif

        case('Number of Random Fields')
            read( value,*) NRand

        case('Kriging variogram form')
            read(value,*) par%form

        case('Use Posterior Sim')
            read(value,*) use_posterior_sim

        !     DEPRECATE
        ! case('Grid File Name')
        !     if (domain_name .ne. value(1:2)) then
        !         write (*,*) term_red, 'Domain Name Mismatch: Expecting ', term_blk, domain_name, term_red, &
        !         &  ' read ', term_blk, value(1:2)
        !         stop 1
        !     endif
            
        !     Call Set_Grid_Data_File_Name(value)

        case('NLS Spatial Fcn File Name')
            call NLS_Set_Config_File_Name(value)

        case('Save Data')
            read(value,*) save_data

        case default
            write(*,*) term_yel, 'ReadInput: Unrecognized line in UK.cfg'
            write(*,*) 'Unrecognized Line->',input_string
            write(*,*) 'This is probably not a problem', term_blk
    end select
    endif
end do
close(69)
endsubroutine Read_Startup_Config
        
!---------------------------------------------------------------------------------------------------
!! Purpose: This subroutine writes files for output.  This includes a central prediction: 
!> "KrigingEstimate.txt" and random fields generated from the posterior distribution:
!> "RandomFieldN.txt", where N =1:Nrand. Predictor standard deviation  is output to "KrigSTD.txt".
!> Function coefficient 
!---------------------------------------------------------------------------------------------------
subroutine OutputUK(num_points, num_spat_fcns, Nrand, grid, nlsf, beta, eps, Ceps, Cbeta, fmax, SF, &
&                  IsLogT, IsHiLimit, domain_name, alpha)
use globals
use GridManagerMod
use NLSF_Mod
use LSF_Mod
use Krig_Mod
implicit none

type(Grid_Data_Class), intent(inout) :: grid
type(NLSF_Class), intent(in)::nlsf(*)
                                    
character(2), intent(in) :: domain_name
integer, intent(in) :: num_points, num_spat_fcns, Nrand
real(dp), intent(in) :: eps(*), beta(*), Cbeta(num_spat_fcns,*), fmax, SF, alpha
real(dp), intent(inout) :: Ceps(num_points,*)
logical, intent(in) ::IsLogT, IsHiLimit
integer j, k, n
real(dp) trend(num_points), V(num_points), Fg(num_points, num_spat_fcns), EnsMu, EnsSTD 
real(dp) logf(num_points), adj, RandomField(num_points, Nrand)
character(72) buf
logical, parameter :: save_data = .true.

write(*,*)'output fmax, SF, A=', fmax, SF, one_scallop_per_tow
do n=1, num_points
    V(n)=Ceps(n, n)
enddo
grid%field_psqm(1:num_points) = grid%field_psqm(1:num_points)**(1./alpha)

logf(1:num_points) = grid%field_psqm(1:num_points)
if(IsLogT) grid%field_psqm(1:num_points) = SF * exp( grid%field_psqm(1:num_points) + V(1:num_points)/2. ) - one_scallop_per_tow  ! adjusted inverse log(one_scallop_per_tow+f)
if(IsHiLimit) call LSF_Limit_Z(num_points, grid%field_psqm, grid%z, fmax, domain_name)
call Write_Vector_Scalar_Field(num_points, grid%field_psqm, 'KrigingEstimate.txt')

Fg = Krig_Eval_Spatial_Function(grid, num_spat_fcns, num_points, nlsf, save_data)
trend(1:num_points) = matmul( Fg(1:num_points, 1:num_spat_fcns), beta(1:num_spat_fcns)) 

if(IsLogT) trend(1:num_points) = SF*exp(trend(1:num_points))-one_scallop_per_tow
call Write_Vector_Scalar_Field(num_points, trend, 'SpatialTrend.txt')

call Write_Vector_Scalar_Field(num_points, eps, 'epsilon.txt')
call Write_Vector_Scalar_Field(num_spat_fcns, beta, 'beta.txt')

call Write_CSV(num_spat_fcns, num_spat_fcns, Cbeta, 'CovBeta.csv', num_spat_fcns, .false.)

Fg = Krig_Eval_Spatial_Function(grid, num_spat_fcns, num_points, nlsf, save_data)
Ceps(1:num_points, 1:num_points) = Ceps(1:num_points, 1:num_points)&
&    + matmul( Fg(1:num_points, 1:num_spat_fcns) , &
&              matmul(Cbeta(1:num_spat_fcns, 1:num_spat_fcns), transpose(Fg(1:num_points, 1:num_spat_fcns)) ) )
do n=1, num_points
   V(n) = Ceps(n, n)
enddo
if(IsLogT) call Write_Vector_Scalar_Field(num_points, SF*exp(sqrt(V(1:num_points)))-one_scallop_per_tow, 'KrigSTD.txt')
if(.not.IsLogT) call Write_Vector_Scalar_Field(num_points, sqrt(V(1:num_points)), 'KrigSTD.txt')

if(IsLogT) call RandomSampleF(num_points, num_points, NRand, logf(1:n), Ceps, RandomField)
if(.not.IsLogT) call RandomSampleF(num_points, num_points, NRand, grid%field_psqm(1:n)**alpha, Ceps, RandomField)
RandomField(1:num_points, 1:Nrand)=RandomField(1:num_points, 1:Nrand)**(1./alpha)
do k=1, num_points
    if(IsLogT) adj = SF * exp(sqrt(V(k))) - one_scallop_per_tow
    if(.not.IsLogT) adj = sqrt(V(k))
    EnsMu = sum(RandomField(k, 1:Nrand)) / float(Nrand)
    EnsSTD = sqrt( sum((RandomField(k, 1:Nrand) - EnsMu)**2 ) / float(Nrand) )
    if(EnsSTD.gt.0.) then
        RandomField(k, 1:Nrand) = grid%field_psqm(k) +( RandomField(k, 1:Nrand) - EnsMu )*adj/EnsSTD
    else
        RandomField(k, 1:Nrand) = grid%field_psqm(k) + RandomField(k, 1:Nrand) - EnsMu 
    endif
    if(IsHiLimit) call LSF_Limit_Z(Nrand, RandomField(k, 1:NRand), grid%z(k)+0.*RandomField(k, 1:NRand), &
                            fmax, domain_name)
enddo

do j=1, Nrand
    write(buf, '(I6)')j
    call Write_Vector_Scalar_Field(num_points, RandomField(1:num_points, j), 'RandomField'//trim(adjustl(buf))//'.txt')
enddo
endsubroutine OutputUK

!---------------------------------------------------------------------------------------------------
!! Purpose: This subroutine only write the interpolated results file for output. Namely, the central 
!> prediction. The file name is take for the observation file name that resides in the Data
!> subdirectory and then written to the Results subdirectory. 
!>
!> Also want to change the name from X_Y_ (UTM) to Lat_Lon_Grid_ (Navigation)
!>
!> That is moving from survey data locations to MA/GB grid locations
!---------------------------------------------------------------------------------------------------
subroutine OutputEstimates(num_points, num_spat_fcns, grid, Ceps, IsLogT, IsHiLimit, fmax, SF, domain_name, nlsf, beta)
use globals
use GridManagerMod
use NLSF_Mod
use LSF_Mod
use Krig_Mod

implicit none

integer, intent(in) :: num_points, num_spat_fcns
type(Grid_Data_Class), intent(inout) :: grid
real(dp), intent(in) :: Ceps(num_points,*)
logical, intent(in) ::IsLogT, IsHiLimit
real(dp), intent(in) :: fmax, SF
character(2), intent(in) :: domain_name

type(NLSF_Class), intent(in)::nlsf(*)
real(dp), intent(in) :: beta(*)

integer n
real(dp) V(num_points)
character(fname_len) fname, fout, ftrend
character(80) fmtstr

real(dp) trend(num_points), Fg(num_points, num_spat_fcns)

do n=1, num_points
    V(n)=Ceps(n, n)
enddo
    
if(IsLogT) grid%field_psqm(1:num_points) = SF * exp( grid%field_psqm(1:num_points) + V(1:num_points)/2. ) - one_scallop_per_tow  ! adjusted inverse log(one_scallop_per_tow+f)
if(IsHiLimit) call LSF_Limit_Z(num_points, grid%field_psqm, grid%z, fmax, domain_name)

fname = Get_Obs_Data_File_Name()
! Change output directory and file prefix
! /X_Y_...
! n12345
n = index(fname, '/') + 5
fout = output_dir//'Lat_Lon_Grid_'//fname(n:)
ftrend = output_dir//'Lat_Lon_Grid_Trend-'//fname(n:)
fmtstr='(2(ES14.7 : ", ") (ES14.7 : ))'

write(*,*) term_blu, 'Writing ouput to: ', trim(fout), term_blk
write(*,*) term_blu, 'Writing ouput to: ', trim(ftrend), term_blk

! This data is the same as what 'KrigingEstimate.txt' held, but now with location information
open(63,file=trim(fout))
do n=1, num_points
    write(63, fmtstr) grid%lat(n), grid%lon(n), grid%field_psqm(n)
enddo
close(63)

! Now let's save the trend information in the same manner
Fg = Krig_Eval_Spatial_Function(grid, num_spat_fcns, num_points, nlsf, .false.)
trend(1:num_points) = matmul( Fg(1:num_points, 1:num_spat_fcns), beta(1:num_spat_fcns)) 

if(IsLogT) trend(1:num_points) = SF*exp(trend(1:num_points))-one_scallop_per_tow
!call Write_Vector_Scalar_Field(num_points, trend, 'SpatialTrend.txt')
open(63,file=trim(ftrend))
do n=1, num_points
    write(63, fmtstr) grid%lat(n), grid%lon(n), trend(n)
enddo
close(63)

endsubroutine OutputEstimates
