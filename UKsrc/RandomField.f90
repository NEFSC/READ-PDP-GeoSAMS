!--------------------------------------------------------------------------------------------------
!> @page page4 Random Fields
!>
!>
!--------------------------------------------------------------------------------------------------
! Keston Smith, Tom Callaghan (IBSS) 2024
!--------------------------------------------------------------------------------------------------
module Random_Field_Mod

use globals
implicit none


CONTAINS

!--------------------------------------------------------------------------------------------------
!! Purpose: Generate independent standard normal samples in a (n x m) matrix (R)
!>
!> Inputs:
!> - n    (integer) number of rows in R
!> - m       (integer) number of columns in R
!>
!>  Outputs:
!>  - R    (real(dp))  Size (num_points x mm) matrix of independent standard normal random variables
!>
!> The algorithm uses the Box Muller transformation to compute independent 
!> standard normal numbers from uniform random numbers generated by the 
!> intrinsic subroutine random_number( ).  For refrence see:
!>
!> Box, G. E. P.; Muller, Mervin E. (1958). "A Note on the Generation of 
!> Random Normal Deviates". The Annals of Mathematical Statistics. 29 
!> (2): 610â€“611. doi:10.1214/aoms/1177706645. JSTOR 2237361
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!--------------------------------------------------------------------------------------------------
subroutine IndStdNRV(n, m, R)
integer,    intent(in)::n, m
real(dp),    intent(out)::R(n,*)
real(dp),    allocatable:: U1(:,:), U2(:,:)
allocate( U1(1:n, 1:m), U2(1:n, 1:m) )
call random_number(U1)
call random_number(U2)
R(1:n, 1:m) = sqrt ( - 2.0D0* log ( U1(1:n, 1:m) ) ) * cos ( 2.0D0 * pi * U2(1:n, 1:m) )
deallocate(U1, U2)
end subroutine

!--------------------------------------------------------------------------------------------------
!! Generate random sample from a multivariate gaussian distribution N(mu, C)
!> where mu is the distribution mean C is the covariance. The number of
!> independent samples drawn is Nsample which are stored in the columns of X.
!>
!> Inputs:
!> - nndim    (integer) Leading dimentsion of C and X
!> - num_points    (integer) Length of mu / dimension of random variable
!> - Nsample (integer) Number of Samples to draw from N(mu, C)
!> - mu    (real(dp))  Length num_points vector, mean of the distribution
!> - C    (real(dp))  Size (num_points x num_points) Covariance matrix of the distribution
!>
!> Outputs:
!> - X       (real(dp))  Size (num_points x Nsample) independent random samples drawn from N(mu, C)
!>
!> Requires: LAPACK and BLAS libraries for Cholesky factorization of C and matrix vector multiplication.
!>
!> INFO is INTEGER
!> = 0:  successful exit
!> < 0:  if INFO = -i, the i-th argument had an illegal value
!> > 0:  if INFO = i, the leading minor of order i is not positive definite, 
!>       and the factorization could not be completed.
!>
!> @author Keston Smith (IBSS corp) June-July 2021
!--------------------------------------------------------------------------------------------------
subroutine RandomSampleF(nndim, num_points, Nsample, mu, C, X)
integer,     intent(in) :: nndim, num_points, Nsample
real(dp),     intent(in) :: mu(*), C(nndim,*)
real(dp),     intent(out)::X(num_points,*)
real(dp),    allocatable::R(:,:), S(:,:)
real(dp)     atmp, btmp
integer     j, k, info
allocate( R(1:num_points, 1:Nsample), S(1:num_points, 1:num_points))
!
! S<-C for cholesky decomposition
!
S(1:num_points, 1:num_points)=C(1:num_points, 1:num_points)
!
! S<-Cholesky(C) so that C = S * S^T
!
call dpotrf('L', num_points, S, num_points, info )
write(*,*)'dpotrf in RandomSample, info=', info
!
! set upper triangular portion of S to 0.
!
do k=1, num_points-1
    S(k, k+1:num_points)=0.
enddo

atmp=1.
btmp=0.
!
! R <- (num_points x Nsample) independent standard normal random numbers R ~ N(0, I(num_points))
!
call IndStdNRV(num_points, Nsample, R)
!
! X <- S * R, X ~ N(0, C)
!
call dgemm('N', 'N', num_points, Nsample, num_points, atmp, S, num_points, R, num_points, btmp, X, num_points )
!
! X <- mu + X, X ~ N(mu, C)
!
do j=1, Nsample
    X(1:num_points, j)=mu(1:num_points)+X(1:num_points, j)
enddo

deallocate(R, S)
end subroutine

end module Random_Field_Mod